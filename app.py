# -*- coding: utf-8 -*-
"""app.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1LKKhFY06o5_ePLU021Jia3PdW9e3MzDe

# 0️⃣ Import Libraries & Drive
"""

#%pip install shap

#%pip install -U kaleido

#%pip install fpdf

import plotly.express as px
import plotly.io as pio

from math import floor, ceil
import math
from plotly.subplots import make_subplots

import numpy as np
import pandas as pd
from sklearn.model_selection import train_test_split

'''
import tensorflow as tf    
tf.compat.v1.disable_v2_behavior() # <-- HERE !

import tensorflow.keras.backend as K
from tensorflow.keras.utils import to_categorical
from tensorflow.python.keras.layers import Dense
from tensorflow.python.keras import Sequential
from tensorflow.keras import optimizers
import keras
print("SHAP version is:", shap.__version__)
print("Tensorflow version is:", tf.__version__)
'''

import matplotlib.pyplot as plt
import sklearn
import seaborn as sns

from sklearn.metrics import confusion_matrix

from sklearn import metrics

import pickle

from sklearn.metrics import accuracy_score, f1_score

from copy import deepcopy

from sklearn.isotonic import IsotonicRegression

import plotly.graph_objects as go
from sklearn.linear_model import LinearRegression

#from fpdf import FPDF

"""# 1️⃣ Performance Functions / Keras Metrics"""

'''#+======================================================================================================+
#|                                         PLOTTING FUNCTIONS                                           |
#+======================================================================================================+
#+------------------------------------------------------------------------------------------------------+
#|                                F2 score computation for plotting                                     |
#+------------------------------------------------------------------------------------------------------+
def f2_score(y_real, pred):
    tn, fp, fn, tp = confusion_matrix(y_real, pred).ravel()
    f2_score = (1 + 2**2) * tp / ((1+2**2) * tp + 2**2 * fn + fp)
    return f2_score

#+------------------------------------------------------------------------------------------------------+
#|                              Plot Performances (Confusion Matrix)                                    |
#+------------------------------------------------------------------------------------------------------+
def plotPerformances(y_pred, y_pred_proba, y_real, matrixLabels, model_name,  title = "Results", norm = True, printMetrics = True):
    # Metrics
    matrix = confusion_matrix(y_real, y_pred, labels=[1, 0])
    TruePositives = matrix[0,0]
    FalseNegatives = matrix[0,1]
    FalsePositives = matrix[1,0]

    norm_matrix = matrix/matrix.sum(axis=1)[:, np.newaxis]

    # Dataframe Conversion
    matrix = pd.DataFrame(matrix, columns = matrixLabels, index =  matrixLabels)
    norm_matrix = pd.DataFrame(norm_matrix, columns = matrixLabels, index =  matrixLabels)


    if norm:
        plot_matrix = norm_matrix
        format = '0.4f'
    else:
        plot_matrix = matrix.astype(int)
        format = '0.0f'

    f1_score = sklearn.metrics.f1_score(y_real, y_pred, average='macro').round(4)
    f2_score = round(((1+2**2)*TruePositives)/(((1+2**2)*TruePositives)+(2**2*FalseNegatives)+FalsePositives),4)
    auc_score = round(metrics.roc_auc_score(y_real,y_pred_proba),4)

    # Plot
    plt.figure(figsize=(8, 10))
    plt.title(title, fontsize=16, fontweight="bold")
    sns.heatmap(plot_matrix, annot=True, fmt=format, cmap="Blues", cbar=False, annot_kws={"fontsize":16})
    if printMetrics:
        plt.figtext(0.2, 0.43, "\nF1: ", fontsize=16, fontweight="bold")
        plt.figtext(0.25, 0.43, str(f1_score), fontsize=16)

        plt.figtext(0.42, 0.43, "\nF2: ", fontsize=16, fontweight="bold")
        plt.figtext(0.47, 0.43, str(f2_score), fontsize=16)

        plt.figtext(0.64, 0.43, "\nAUC: ", fontsize=16, fontweight="bold")
        plt.figtext(0.72, 0.43, str(auc_score), fontsize=16)


    plt.subplots_adjust(bottom=0.5)
    plt.tight_layout
    #plt.savefig(''.join([results_directory, '/CMatrix_', model_name, '.png']))
    plt.show()
    return(f2_score, auc_score)

#+------------------------------------------------------------------------------------------------------+
#|                                            Plot Roc Curve                                            |
#+------------------------------------------------------------------------------------------------------+
def plotROC(y_pred_proba, y_real, title):
    
    fpr, tpr, _ = metrics.roc_curve(y_real,  y_pred_proba)
    plt.style.use('seaborn-darkgrid')
    plt.figure(figsize=(8, 6))
    
    #create ROC curve
    plt.title(title, fontsize=16, fontweight="bold")
    
    plt.plot(fpr,tpr)
    plt.ylabel('True Positive Rate')
    plt.xlabel('False Positive Rate')

    plt.tight_layout
    #plt.style.use('fivethirtyeight')
    plt.show()
    plt.close()
    
#+======================================================================================================+
#|                                            KERAS METRICS                                             |
#+======================================================================================================+
#+------------------------------------------------------------------------------------------------------+
#|                                    Recall - Precision - f1 - f2                                      |
#+------------------------------------------------------------------------------------------------------+
def recall_m(y_true, y_pred):
    true_positives = K.sum(K.round(K.clip(y_true * y_pred, 0, 1)))
    possible_positives = K.sum(K.round(K.clip(y_true, 0, 1)))
    recall = true_positives / (possible_positives + K.epsilon())
    return recall

def precision_m(y_true, y_pred):
    true_positives = K.sum(K.round(K.clip(y_true * y_pred, 0, 1)))
    predicted_positives = K.sum(K.round(K.clip(y_pred, 0, 1)))
    precision = true_positives / (predicted_positives + K.epsilon())
    return precision

def f1_m(y_true, y_pred):
    precision = precision_m(y_true, y_pred)
    recall = recall_m(y_true, y_pred)
    return 2*((precision*recall)/(precision+recall+K.epsilon()))

def f2(y_true, y_pred):
    tp = K.sum(K.round(K.clip(y_true * y_pred, 0, 1)))
    fp = K.sum(K.round(K.clip((1-y_true) * y_pred, 0, 1))) # Calcolo i falsi postivi con 1-y_true
    fn = K.sum(K.round(K.clip(y_true * (1-y_pred), 0, 1)))

    f2_score = (1 + 2**2) * tp / ((1+2**2) * tp + 2**2 * fn + fp + K.epsilon())
    return f2_score
'''

"""# 2️⃣ Data Import

"""

# PROJECT ROOT DEFINITION
projectRoot = "./"
# random change
#+------------------------------------------------------------------------------------------------------+
#|                                           EVENT DEATH DATA                                           |
#+------------------------------------------------------------------------------------------------------+
## FEATURES
# X Train
with open(projectRoot + 'data/sX_train_over.pickle', 'rb') as handle:
    sX_train_death = pickle.load(handle)
# X Val
with open(projectRoot + 'data/sX_val2.pickle', 'rb') as handle:
    sX_val_death = pickle.load(handle)
with open(projectRoot + 'data/X_val2.pickle', 'rb') as handle:
    X_val_death = pickle.load(handle)
# X Test
with open(projectRoot + 'data/sX_test.pickle', 'rb') as handle:
    sX_test_death = pickle.load(handle)
with open(projectRoot + 'data/X_test.pickle', 'rb') as handle:
    X_test_death = pickle.load(handle)

## TARGETS
# Y Train
with open(projectRoot + 'data/y_train_over.pickle', 'rb') as handle:
    y_train_death = pickle.load(handle)
# Y val
with open(projectRoot + 'data/y_test.pickle', 'rb') as handle:
    y_test_death = pickle.load(handle)
# Y test
with open(projectRoot + 'data/y_val2.pickle', 'rb') as handle:
    y_val_death = pickle.load(handle)
    
    
#+------------------------------------------------------------------------------------------------------+
#|                                         EVENT BARC MB DATA                                           |
#+------------------------------------------------------------------------------------------------------+
## FEATURES
# X Train
with open(projectRoot + 'data/BARC/sX_train_barc.pkl', 'rb') as handle:
    sX_train_barc = pickle.load(handle)
# X Val
with open(projectRoot + 'data/BARC/sX_val_barc.pkl', 'rb') as handle:
    sX_val_barc = pickle.load(handle)
with open(projectRoot + 'data/BARC/X_val_barc.pkl', 'rb') as handle:
    X_val_barc = pickle.load(handle)
# X Test
with open(projectRoot + 'data/BARC/sX_test_barc.pkl', 'rb') as handle:
    sX_test_barc = pickle.load(handle)
with open(projectRoot + 'data/BARC/X_test_barc.pkl', 'rb') as handle:
    X_test_barc = pickle.load(handle)
    
## TARGETS
# Y Train
with open(projectRoot + 'data/BARC/y_train_barc.pkl', 'rb') as handle:
    y_train_barc = pickle.load(handle)
# Y val
with open(projectRoot + 'data/BARC/y_val_barc.pkl', 'rb') as handle:
    y_val_barc = pickle.load(handle)
# Y test
with open(projectRoot + 'data/BARC/y_test_barc.pkl', 'rb') as handle:
    y_test_barc = pickle.load(handle)
    
#+------------------------------------------------------------------------------------------------------+
#|                                 CONVERSION IN KERAS TENSOR                                           |
#+------------------------------------------------------------------------------------------------------+
'''
## DEATH
kX_train_death = tf.convert_to_tensor(sX_train_death)
kX_val_death = tf.convert_to_tensor(sX_val_death)
kX_test_death = tf.convert_to_tensor(sX_test_death)
## BARC
kX_train_barc = tf.convert_to_tensor(sX_train_barc)
kX_val_barc = tf.convert_to_tensor(sX_val_barc)
kX_test_barc = tf.convert_to_tensor(sX_test_barc)
'''

"""# 3️⃣ Model Import / Predictions / Performance"""

'''## DEATH MODEL
modelFolderDeath = projectRoot + "models/DeathModel_May31_22-51-34/ckpts/cp.ckpt"

## BARC MODEL
#modelFolderBarc = projectRoot + "models/BarcModel_Jun19_08-55-54/ckpts/cp.ckpt"
#modelFolderBarc = projectRoot + "models/BarcModel_Jul12_21-38-09/ckpts/cp.ckpt"
#modelFolderBarc = projectRoot + "models/BarcModel_Jul12_22-07-08/ckpts/cp.ckpt"
modelFolderBarc = projectRoot + "models/BarcModel_Jul12_22-26-15/ckpts/cp.ckpt"
#modelFolderBarc = projectRoot + "models/BarcModel_Jul13_09-54-33/ckpts/cp.ckpt"
#+------------------------------------------------------------------------------------------------------+
#|                                            MODEL IMPORT                                              |
#+------------------------------------------------------------------------------------------------------+
modelDeath = keras.models.load_model(modelFolderDeath, custom_objects={"f2": f2, "auc": tf.keras.metrics.AUC()})
modelBarc = keras.models.load_model(modelFolderBarc, custom_objects={"f2": f2, "auc": tf.keras.metrics.AUC()})
'''

'''#+------------------------------------------------------------------------------------------------------+
#|                                           PREDICTION DEATH                                           |
#+------------------------------------------------------------------------------------------------------+
# Prediction VAL
y_pred_proba_val_death = modelDeath.predict(sX_val_death).squeeze()
y_pred_val_death = np.where(y_pred_proba_val_death > 0.5, 1,0)
accuracy_val_death = accuracy_score(y_val_death, y_pred_val_death).round(4)
f1_val_death = f1_score(y_val_death, y_pred_val_death, average='macro').round(4)

# Plot And Save Prediction
f2_val_death, auc_val_death = plotPerformances(y_pred_val_death, y_pred_proba_val_death, y_val_death,
                                               model_name = "Validation_death", matrixLabels=["D", "ND"], 
                                               title = " Validation death", norm = False, printMetrics = True)
# Prediction TEST
y_pred_proba_test_death = modelDeath.predict(sX_test_death).squeeze()
y_pred_test_death = np.where(y_pred_proba_test_death > 0.5, 1,0)
accuracy_death = accuracy_score(y_test_death, y_pred_test_death).round(4)
f1_test = f1_score(y_test_death, y_pred_test_death, average='macro').round(4)

# Plot and save Prediction
f2_test_death, auc_test_death = plotPerformances(y_pred_test_death, y_pred_proba_test_death, y_test_death, 
                                                 model_name = "Test_death",matrixLabels=["D", "ND"], 
                                                 title = " Test death", norm = False, printMetrics = True)

#+------------------------------------------------------------------------------------------------------+
#|                                           PREDICTION BARC                                            |
#+------------------------------------------------------------------------------------------------------+
# Prediction VAL
y_pred_proba_val_barc = modelBarc.predict(sX_val_barc).squeeze()
y_pred_val_barc = np.where(y_pred_proba_val_barc > 0.5, 1,0)
accuracy_val_barc = accuracy_score(y_val_barc, y_pred_val_barc).round(4)
f1_val_barc = f1_score(y_val_barc, y_pred_val_barc, average='macro').round(4)

# Plot And Save Prediction
f2_val_barc, auc_val_barc = plotPerformances(y_pred_val_barc, y_pred_proba_val_barc, y_val_barc,
                                               model_name = "Validation_BARC", matrixLabels=["B", "NB"], 
                                               title = " Validation BARC", norm = False, printMetrics = True)
# Prediction TEST
y_pred_proba_test_barc = modelBarc.predict(sX_test_barc).squeeze()
y_pred_test_barc = np.where(y_pred_proba_test_barc > 0.5, 1,0)
accuracy_barc = accuracy_score(y_test_barc, y_pred_test_barc).round(4)
f1_test = f1_score(y_test_barc, y_pred_test_barc, average='macro').round(4)

# Plot and save Prediction
f2_test_barc, auc_test_barc = plotPerformances(y_pred_test_barc, y_pred_proba_test_barc, y_test_barc, 
                                                 model_name = "Test_BARC",matrixLabels=["B", "NB"], 
                                                 title = " Test BARC", norm = False, printMetrics = True)
'''

## SAVING CHECKPOINT
# Questo serve per salvare tutti gli oggetti che dipendono da Keras e che devono essere usati per la generazione del modello SHAP
'''
with open('C:/Users/kkass/Desktop/Polimi/Laurea/ASP/ProjectApp/objects/y_pred_proba_val_barc.pickle', 'wb') as handle:
    pickle.dump(y_pred_proba_val_barc, handle, protocol=pickle.HIGHEST_PROTOCOL)
with open('C:/Users/kkass/Desktop/Polimi/Laurea/ASP/ProjectApp/objects/y_pred_proba_val_death.pickle', 'wb') as handle:
    pickle.dump(y_pred_proba_val_death, handle, protocol=pickle.HIGHEST_PROTOCOL)
with open('C:/Users/kkass/Desktop/Polimi/Laurea/ASP/ProjectApp/objects/y_pred_proba_test_barc.pickle', 'wb') as handle:
    pickle.dump(y_pred_proba_test_barc, handle, protocol=pickle.HIGHEST_PROTOCOL)
with open('C:/Users/kkass/Desktop/Polimi/Laurea/ASP/ProjectApp/objects/y_pred_proba_test_death.pickle', 'wb') as handle:
    pickle.dump(y_pred_proba_test_death, handle, protocol=pickle.HIGHEST_PROTOCOL)
'''
# CHECKPOINT LOADER
with open('./objects/y_pred_proba_val_barc.pickle', 'rb') as handle:
    y_pred_proba_val_barc = pickle.load(handle)
with open('./objects/y_pred_proba_val_death.pickle', 'rb') as handle:
    y_pred_proba_val_death = pickle.load(handle)
with open('./objects/y_pred_proba_test_barc.pickle', 'rb') as handle:
    y_pred_proba_test_barc = pickle.load(handle)
with open('./objects/y_pred_proba_test_death.pickle', 'rb') as handle:
    y_pred_proba_test_death = pickle.load(handle)  
#'''

#+------------------------------------------------------------------------------------------------------+
#|                                      ISOTONIC REGRESSION FITTING                                     |
#+------------------------------------------------------------------------------------------------------+
#---------------------------------------------------BARC------------------------------------------------+
iso_reg_barc = IsotonicRegression(out_of_bounds = 'clip').fit(y_pred_proba_val_barc, y_val_barc)
#--------------------------------------------------DEATH------------------------------------------------+
iso_reg_death = IsotonicRegression(out_of_bounds = 'clip').fit(y_pred_proba_val_death, y_val_death)

y_pred_proba_val_death.sort()

y_pred_proba_test_death.sort()

pdtaIsotinicThreshold = iso_reg_barc.predict(np.expand_dims(0.5, axis=0))
pdtaIsotinicThreshold = round(pdtaIsotinicThreshold[0]*100,4)

from sklearn.calibration import CalibratedClassifierCV, calibration_curve
from sklearn.metrics import brier_score_loss

def plot_calibration_curve(name,  y_test, probs, iso_reg, n_bins):
    """Plot calibration curve for est w/o and with calibration. """
    sns.set_style("whitegrid")

    fig = plt.figure(figsize=(10, 10))
    ax1 = plt.subplot2grid((3, 1), (0, 0), rowspan=2)
    ax2 = plt.subplot2grid((3, 1), (2, 0))
    
    ax1.plot([0, 1], [0, 1], "k:", label="Perfectly calibrated", linewidth=2)
    
    frac_of_pos, mean_pred_value = calibration_curve(y_test, probs, n_bins=n_bins)
    frac_of_pos_isotonic, mean_pred_value_isotonic = calibration_curve(y_test, iso_reg.predict(probs), n_bins=n_bins)
    model_score = round(brier_score_loss(y_test, probs, pos_label=y_test.max()),4)
    isotonic_score = round(brier_score_loss(y_test,  iso_reg.predict(probs), pos_label=y_test.max()), 4)


    ax1.plot(mean_pred_value, frac_of_pos, "-", label= 'Original Model → Brier Loss: '+str(model_score), color="#1C3144", linewidth=2, markersize=6, marker = "o") #0077B6
    ax1.plot(mean_pred_value_isotonic, frac_of_pos_isotonic, "-", label= 'Isotonic Regression → Brier Loss: '+str(isotonic_score), color="#00B4D8", linewidth=2, markersize=6, marker = "o")
    ax1.set_ylabel("Fraction of positives",  fontsize=16)
    ax1.set_ylim([-0.05, 1.05])
    ax1.legend(loc="best",  fontsize=14)
    ax1.set_title(f'Calibration plot ({name})',  fontsize=16, fontweight="bold")
    
    ax2.hist(probs, range=(0, 1), bins=n_bins, label="Original Model", histtype="barstacked", lw=2, alpha=0.9, color="#1C3144") 
    ax2.hist(iso_reg_death.predict(probs), range=(0, 1), bins=n_bins, label="Isotonic Regression", histtype="barstacked", lw=2,  alpha=0.5, color="#00B4D8")
    ax2.set_xlabel("Mean predicted value",  fontsize=16)
    ax2.set_ylabel("Count",  fontsize=16)
    ax2.legend(loc="best",  fontsize=14)

plot_calibration_curve("Model Death - Test Set",  y_test_death, y_pred_proba_test_death, iso_reg_death, 10)

plot_calibration_curve("Model Bleeding - Test Set",  y_test_barc, y_pred_proba_test_barc, iso_reg_barc, 20)

"""# 4️⃣ SHAP

## Plotting Functions

#### SCatter
"""

def shapScatter(data, x, y, colorData, labels, title, facet=True, savePNG = False, saveHTML = False, plot = True, directory = "", filename = ""):
  if facet:
    plotlyfig = px.scatter(data, x=x, y=y, template="plotly_white",
              color = colorData, color_discrete_sequence= ["#86B4D5", "#4D8EBE", "#2A6078", "#20425B"], #color["#95BDDA", "#5A98C4", "#356E97", "#1B374B"],
              title = "<b>"+title+"</b><br>➊ Color: <i>"+labels[2]+"</i>",
              width=1400, height=700,
              facet_col=colorData,
              symbol = colorData,
              labels={
                  x: labels[0],
                  y: labels[1],
                  colorData: labels[2],
              })  
    
    plotlyfig.update_traces(marker=dict(size=4))
    if plot:
        plotlyfig.show()

  else:

    # Regression
    X = data[x].values.reshape(-1, 1)

    regModel = LinearRegression()
    regModel.fit(X, data[y])

    x_range = np.linspace(X.min(), X.max(), 100)
    y_range = regModel.predict(x_range.reshape(-1, 1))

    plotlyfig = px.scatter(data, x=x, y=y, template="plotly_white",
              color = colorData, 
              color_discrete_sequence = ["#4D8EBE"],#["#95BDDA", "#5A98C4", "#356E97", "#1B374B"],
              #symbol = colorData,
              #trendline="ols",
              title = "<b>"+title+"</b><br>➊ Color: <i>"+labels[2]+"</i>",
              width=1400, height=700,
              opacity=0.65,
              labels={
                  x: labels[0],
                  y: labels[1],
                  colorData: labels[2]
              })  
    
    plotlyfig.add_traces(go.Scatter(x=x_range, y=y_range, name='Regression Fit', line_color = "#356E97"))

    plotlyfig.update_traces(marker=dict(size=5))
    if plot:
        plotlyfig.show()
    #print("Regression Coefficient: \t\t", regModel.coef_)
    #print("Regression Intercept: \t\t", regModel.intercept_)

  if savePNG:
    print("Saved PNG: ", str(directory+filename+".png"))
    pio.write_image(plotlyfig, str(directory+filename+".png"), scale=4)

  if saveHTML:
    print("Saved HTML: ", str(directory+filename+".html"))
    plotlyfig.write_html(str(directory+filename+".html"))

  return(regModel.coef_, regModel.intercept_)

def linearRegression(data, x, y):
    # Regression
    X = data[x].values.reshape(-1, 1)
    # Regression Model
    regModel = LinearRegression()
    regModel.fit(X, data[y])

    return(regModel.coef_, regModel.intercept_)

def exponentialFitting(data, x, y):
    X = np.array(data[x])
    Y = np.array(data[y])
    popt, pcov = curve_fit(func, X, Y)
    return(popt)

def shapScatterPolyFit(data, x, y, colorData, labels, title, facet=True, poly=3, savePNG = False, saveHTML = False, directory = "", filename = ""):
  X = np.array(data[x])
  Y = np.array(data[y])
  z = np.polyfit(X, Y, poly)
  p = np.poly1d(z)

  x_range = np.linspace(X.min(), X.max(), 100)
  y_range = p(x_range)

  plotlyfig = px.scatter(data, x=x, y=y, template="plotly_white",
            #color = colorData, 
            color_discrete_sequence = ["#4D8EBE"],#["#95BDDA", "#5A98C4", "#356E97", "#1B374B"],
            #symbol = colorData,
            #trendline="ols",
            title = "<b>"+title+"</b><br>➊ Color: <i>"+labels[2]+"</i>",
            width=1400, height=700,
            opacity=0.65,
            labels={
                x: labels[0],
                y: labels[1],
                colorData: labels[2]
            })  
  
  plotlyfig.add_traces(go.Scatter(x=x_range, y=y_range, name='Regression Fit', line_color = "#356E97"))

  plotlyfig.update_traces(marker=dict(size=5))
  plotlyfig.show()
  #print("Regression Coefficient: \t\t", regModel.coef_)
  #print("Regression Intercept: \t\t", regModel.intercept_)

  if savePNG:
    print("Saved PNG: ", str(directory+filename+".png"))
    pio.write_image(plotlyfig, str(directory+filename+".png"), scale=4)

  if saveHTML:
    print("Saved HTML: ", str(directory+filename+".html"))
    plotlyfig.write_html(str(directory+filename+".html"))

  return(z, p)

def shapScatterExpFit(data, x, y, colorData, labels, title, facet=True, savePNG = False, saveHTML = False, plot=True, directory = "", filename = ""):
  

  X = np.array(data[x])
  Y = np.array(data[y])
  popt, pcov = curve_fit(expFunction, X, Y)

  x_range = np.linspace(X.min(), X.max(), 100)
  y_range = func(x_range, *popt)

  plotlyfig = px.scatter(data, x=x, y=y, template="plotly_white",
            #color = colorData, 
            color_discrete_sequence = ["#4D8EBE"],#["#95BDDA", "#5A98C4", "#356E97", "#1B374B"],
            symbol = colorData,
            #trendline="ols",
            title = "<b>"+title+"</b><br>➊ Color: <i>"+labels[2]+"</i>",
            width=1000, height=500,
            opacity=0.65,
            labels={
                x: labels[0],
                y: labels[1],
                colorData: labels[2]
            })  
  
  plotlyfig.add_traces(go.Scatter(x=x_range, y=y_range, name='Regression Fit', line_color = "#356E97"))

  plotlyfig.update_traces(marker=dict(size=5))
  if plot:
      plotlyfig.show()
  #print("Regression Coefficient: \t\t", regModel.coef_)
  #print("Regression Intercept: \t\t", regModel.intercept_)

  if savePNG:
    print("Saved PNG: ", str(directory+filename+".png"))
    pio.write_image(plotlyfig, str(directory+filename+".png"), scale=4)

  if saveHTML:
    print("Saved HTML: ", str(directory+filename+".html"))
    plotlyfig.write_html(str(directory+filename+".html"))

  return(popt)

def shapScatterParabolicFit(data, x, y, colorData, labels, title, facet=True, savePNG = False, saveHTML = False, plot=True, directory = "", filename = ""):
  

  X = np.array(data[x])
  Y = np.array(data[y])
  popt, pcov = curve_fit(parabolicFunction, X, Y)

  x_range = np.linspace(X.min(), X.max(), 100)
  y_range = parabolicFunction(x_range, *popt)

  plotlyfig = px.scatter(data, x=x, y=y, template="plotly_white",
            #color = colorData, 
            color_discrete_sequence = ["#4D8EBE"],#["#95BDDA", "#5A98C4", "#356E97", "#1B374B"],
            symbol = colorData,
            #trendline="ols",
            title = "<b>"+title+"</b><br>➊ Color: <i>"+labels[2]+"</i>",
            width=1000, height=500,
            opacity=0.65,
            labels={
                x: labels[0],
                y: labels[1],
                colorData: labels[2]
            })  
  
  plotlyfig.add_traces(go.Scatter(x=x_range, y=y_range, name='Regression Fit', line_color = "#356E97"))

  plotlyfig.update_traces(marker=dict(size=5))
  if plot:
      plotlyfig.show()
  #print("Regression Coefficient: \t\t", regModel.coef_)
  #print("Regression Intercept: \t\t", regModel.intercept_)

  if savePNG:
    print("Saved PNG: ", str(directory+filename+".png"))
    pio.write_image(plotlyfig, str(directory+filename+".png"), scale=4)

  if saveHTML:
    print("Saved HTML: ", str(directory+filename+".html"))
    plotlyfig.write_html(str(directory+filename+".html"))

  return(popt)

"""#### BOXPLOTS"""

def shapBox(data, x, y, colorData, labels, title, facet=True, savePNG = False, saveHTML = False, plot = True, directory = "", filename = ""):
  if facet:
    plotlyfig = px.box(data, x=x, y=y, template="plotly_white",
              color = colorData, color_discrete_sequence= ["#86B4D5", "#4D8EBE", "#2A6078", "#20425B"],#["#95BDDA", "#5A98C4", "#356E97", "#1B374B"],
              title = "<b>"+title+"</b><br>➊ Color: <i>"+labels[2]+"</i>",
              width=1400, height=700,
              facet_col=colorData,
              points="all",
              labels={
                  x: labels[0],
                  y: labels[1],
                  colorData: labels[2],
              })  
    
    plotlyfig.update_traces(marker=dict(size=4))
    if plot:
        plotlyfig.show()

  else:
    plotlyfig = px.box(data, x=x, y=y, template="plotly_white",
              #color = colorData, 
              color_discrete_sequence= ["#4D8EBE"],#["#95BDDA", "#5A98C4", "#356E97", "#1B374B"],
              #symbol = colorData,
              points="all",
              title = "<b>"+title+"</b><br>➊ Color: <i>"+labels[2]+"</i>",
              width=1400, height=700,
              labels={
                  x: labels[0],
                  y: labels[1],
                  colorData: labels[2],
              }
              )  

    plotlyfig.update_traces(marker=dict(size=5))
    if plot:
        plotlyfig.show()

  if savePNG:
    print("Saved PNG: ", str(directory+filename+".png"))
    pio.write_image(plotlyfig, str(directory+filename+".png"), scale=4)

  if saveHTML:
    print("Saved HTML: ", str(directory+filename+".html"))
    plotlyfig.write_html(str(directory+filename+".html"))

  return data[data[x]==0][y].median(), data[data[x]==1][y].median()

np.random.seed(42)

"""# SHAP"""

'''#+------------------------------------------------------------------------------------------------------+
#|                                        BACKGROUND COMPUTATION                                        |
#+------------------------------------------------------------------------------------------------------+
#----------------------------------------------- DEATH --------------------------------------------------
# Select a set of background examples to take an expectation over
background_death = sX_train_death.iloc[np.random.choice(sX_train_death.shape[0], 400, replace=False)]
# Compute The Explainer
explainer_death = shap.DeepExplainer(modelDeath, background_death)
#----------------------------------------------- BARC --------------------------------------------------
# Select a set of background examples to take an expectation over
background_barc = sX_train_barc.iloc[np.random.choice(sX_train_barc.shape[0], 400, replace=False)]
# Compute The Explainer
explainer_barc = shap.DeepExplainer(modelBarc, background_barc)
#+------------------------------------------------------------------------------------------------------+
#|                                        BASELINE COMPUTATION                                          |
#+------------------------------------------------------------------------------------------------------+
baseline_death = explainer_death.expected_value[0]
baseline_death
baseline_barc = explainer_barc.expected_value[0]
print("Baseline Death:", baseline_death, "\nBaseline Barc: ", baseline_barc)


# Compute the Shap Values over the Test
shap_values_death = explainer_death.shap_values(sX_val_death.values)
# Compute the Shap Values over the Test
shap_values_barc = explainer_barc.shap_values(sX_val_barc.values)'''

## SAVING CHECKPOINT
# Questo serve per salvare tutti gli oggetti che dipendono da Keras e che devono essere usati per la generazione del modello SHAP
'''
with open('C:/Users/kkass/Desktop/Polimi/Laurea/ASP/ProjectApp/objects/background_death.pickle', 'wb') as handle:
    pickle.dump(background_death, handle, protocol=pickle.HIGHEST_PROTOCOL)
with open('C:/Users/kkass/Desktop/Polimi/Laurea/ASP/ProjectApp/objects/baseline_death.pickle', 'wb') as handle:
    pickle.dump(baseline_death, handle, protocol=pickle.HIGHEST_PROTOCOL)
with open('C:/Users/kkass/Desktop/Polimi/Laurea/ASP/ProjectApp/objects/shap_values_death.pickle', 'wb') as handle:
    pickle.dump(shap_values_death, handle, protocol=pickle.HIGHEST_PROTOCOL)

with open('C:/Users/kkass/Desktop/Polimi/Laurea/ASP/ProjectApp/objects/background_barc.pickle', 'wb') as handle:
    pickle.dump(background_barc, handle, protocol=pickle.HIGHEST_PROTOCOL)
with open('C:/Users/kkass/Desktop/Polimi/Laurea/ASP/ProjectApp/objects/baseline_barc.pickle', 'wb') as handle:
    pickle.dump(baseline_barc, handle, protocol=pickle.HIGHEST_PROTOCOL)
with open('C:/Users/kkass/Desktop/Polimi/Laurea/ASP/ProjectApp/objects/shap_values_barc.pickle', 'wb') as handle:
    pickle.dump(shap_values_barc, handle, protocol=pickle.HIGHEST_PROTOCOL)
'''

# CHECKPOINT LOADER
with open('./objects/background_death.pickle', 'rb') as handle:
    background_death = pickle.load(handle)
with open('./objects/baseline_death.pickle', 'rb') as handle:
    baseline_death = pickle.load(handle)
with open('./objects/shap_values_death.pickle', 'rb') as handle:
    shap_values_death = pickle.load(handle)

with open('./objects/background_barc.pickle', 'rb') as handle:
    background_barc = pickle.load(handle)
with open('./objects/baseline_barc.pickle', 'rb') as handle:
    baseline_barc = pickle.load(handle)
with open('./objects/shap_values_barc.pickle', 'rb') as handle:
    shap_values_barc = pickle.load(handle)

"""## Feature Importance / Shap Dataset"""

#+------------------------------------------------------------------------------------------------------+
#|                                        DEATH DATASET GENERATION                                      |
#+------------------------------------------------------------------------------------------------------+
''' 
Generation of the dataset with all the features and the relative weight computed by shap
'''

#print("Shap values number DEATH: ", len(shap_values_death[0]))

# Generation of the Shap Dataset
shapIndexes_death = [str(i+"_SHAP") for i in list(sX_val_death.columns)]
shap_df_death = pd.DataFrame(shap_values_death[0], columns = shapIndexes_death)
shap_df_death.reset_index(inplace=True, drop = True)

# Generation of Mean Absolute SHAP Values
meanShap_df_death = abs(shap_df_death).mean().to_frame(name="Mean")
meanShap_df_death["FeatureName"] = sX_val_death.columns
meanShap_df_death.sort_values(by="Mean", ascending=False, inplace=True)
meanShap_df_death["MeanNorm"]=(meanShap_df_death["Mean"]/meanShap_df_death["Mean"].sum())

# Computation of the features Importance Dictionary
meanShap_df_death_percentage = deepcopy(meanShap_df_death)
meanShap_df_death_percentage["Contribution"] = meanShap_df_death_percentage["MeanNorm"]/meanShap_df_death_percentage["MeanNorm"].sum()
featureImportance_death = meanShap_df_death_percentage[["FeatureName", "Contribution"]]
featureImportance_death = featureImportance_death.set_index("FeatureName")
featureImportance_death = dict(featureImportance_death["Contribution"])

#+------------------------------------------------------------------------------------------------------+
#|                                        BARC DATASET GENERATION                                       |
#+------------------------------------------------------------------------------------------------------+
''' 
Generation of the dataset with all the features and the relative weight computed by shap
'''


# Generation of the Shap Dataset
shapIndexes_barc = [str(i+"_SHAP") for i in list(sX_val_barc.columns)]
shap_df_barc = pd.DataFrame(shap_values_barc[0], columns = shapIndexes_barc)
shap_df_barc.reset_index(inplace=True, drop = True)

# Generation of Mean Absolute SHAP Values
meanShap_df_barc = abs(shap_df_barc).mean().to_frame(name="Mean")
meanShap_df_barc["FeatureName"] = sX_val_barc.columns
meanShap_df_barc.sort_values(by="Mean", ascending=False, inplace=True)
meanShap_df_barc["MeanNorm"]=(meanShap_df_barc["Mean"]/meanShap_df_barc["Mean"].sum())

# Computation of the features Importance dictionary
meanShap_df_barc_percentage = deepcopy(meanShap_df_barc)
meanShap_df_barc_percentage["Contribution"] = meanShap_df_barc_percentage["MeanNorm"]/meanShap_df_barc_percentage["MeanNorm"].sum()
featureImportance_barc = meanShap_df_barc_percentage[["FeatureName", "Contribution"]]
featureImportance_barc = featureImportance_barc.set_index("FeatureName")
featureImportance_barc = dict(featureImportance_barc["Contribution"])

#+------------------------------------------------------------------------------------------------------+
#|                                DEATH FEATURE IMPORTANCE PRINTING                                     |
#+------------------------------------------------------------------------------------------------------+
plotlyfig = px.bar(meanShap_df_death, x="FeatureName", y="MeanNorm", template="plotly_white",
                   title = "Mean Features Importance DEATH",
                   color_discrete_sequence= ["#86B4D5", "#4D8EBE", "#2A6078", "#20425B"],)#["#95BDDA", "#5A98C4", "#356E97", "#1B374B"],)  
    
plotlyfig.show()
#+------------------------------------------------------------------------------------------------------+
#|                                 BARC FEATURE IMPORTANCE PRINTING                                     |
#+------------------------------------------------------------------------------------------------------+
plotlyfig = px.bar(meanShap_df_barc, x="FeatureName", y="MeanNorm", template="plotly_white",
                   title = "Mean Features Importance BARC",
                   color_discrete_sequence= ["#86B4D5", "#4D8EBE", "#2A6078", "#20425B"],)#["#95BDDA", "#5A98C4", "#356E97", "#1B374B"],)  
    
plotlyfig.show()

meanShap_df_death[["MeanNorm"]]

plt.figure(figsize=(16, 4))
plt.title("Global Feature Interpretation - Death Model",fontsize=16, fontweight="bold")
sns.barplot(x="FeatureName", y="MeanNorm",data = meanShap_df_death, palette="Blues_r")
plt.ylabel("Relative Feature Importance",  fontsize=14)
plt.xlabel("Features",  fontsize=14)
plt.xticks(rotation=45, ha='right', fontsize=12)
plt.yticks(rotation=0, ha='right', fontsize=12)
plt.show()



plt.figure(figsize=(16, 4))
plt.title("Global Feature Interpretation - Bleeding Model",fontsize=16, fontweight="bold")
sns.barplot(x="FeatureName", y="MeanNorm",data = meanShap_df_barc, palette="Blues_r")
plt.ylabel("Relative Feature Importance",  fontsize=14)
plt.xlabel("Features",  fontsize=14)
plt.xticks(rotation=45, ha='right', fontsize=12)
plt.yticks(rotation=0, ha='right', fontsize=12)
plt.show()

'''pdf = FPDF(orientation='P', unit='mm', format='A4')
pdf.add_page()
pio.write_image((projectRoot+'generatedDocuments/test.pdf'g, str(directory+filename+".png"), scale=4)
pdf.image(projectRoot + 'images/AspLogo.png', x = 6, y = 6)
pdf.output(projectRoot+'generatedDocuments/test.pdf','F')
pdf_w=210
pdf_h=297'''

"""## SHAP MODEL: Classes Definition"""

from scipy.optimize import curve_fit

def expFunction(x, a, c):
    gamma = 0.0000001
    #return a * np.exp(-b * x) + c
    #return a*np.log(x) + b
    return a*np.log(x+gamma) + c

def parabolicFunction(x, a, b, c):
    return a*(x**2) + b*x + c

def linearFunction(x, a, b):
    return a*x + b
'''
Class linearFeature:

Attributes
----------
a: float
    coefficient a of the equation: a*x + b
c: float
    coefficient c of the equation: a*x + b
    
Functions
----------
__init__: Fit and save the coefficient a and c from the x and y coordinates that belong to the pandas dataframe "data" 

predict: Use the fitted equation to predict the y value using the x parameter

'''
class linearFeature:
    # Exponential features have the following formula: a*x + b
    def __init__(self, data, x, y):
        self.type = "linear"
        X = np.array(data[x])
        Y = np.array(data[y])
        coefficients, pcov = curve_fit(linearFunction, X, Y)
        self.a = coefficients[0]
        self.b = coefficients[1]
        
    def predict(self, x, female = None):
        return(linearFunction(x, self.a, self.b))
    
'''
Class expFeature:

Attributes
----------
a: float
    coefficient a of the equation: a*np.log(x) + c
c: float
    coefficient c of the equation: a*np.log(x) + c
    
Functions
----------
__init__: Fit and save the coefficient a and c from the x and y coordinates that belong to the pandas dataframe "data" 

predict: Use the fitted equation to predict the y value using the x parameter

'''
class expFeature:
    # Exponential features have the following formula: a*np.log(x) + c
    def __init__(self, data, x, y):
        self.type = "exponential"
        X = np.array(data[x])
        Y = np.array(data[y])
        coefficients, pcov = curve_fit(expFunction, X, Y)
        self.a = coefficients[0]
        self.c = coefficients[1]
        
    def predict(self, x, female = None):
        return(expFunction(x, self.a, self.c))
    
'''
Class expFeature:

Attributes
----------
a: float
    coefficient a of the equation: a*np.log(x) + c
c: float
    coefficient c of the equation: a*np.log(x) + c
    
Functions
----------
__init__: Fit and save the coefficient a and c from the x and y coordinates that belong to the pandas dataframe "data" 

predict: Use the fitted equation to predict the y value using the x parameter

'''
class expFeatureBySex:
    # Exponential features have the following formula: a*np.log(x) + c
    def __init__(self, data, x, y):
        dataByGenderFemale = data[data["Female"]==1]
        dataByGenderMale = data[data["Female"]==0]
        
        X_Female = np.array(dataByGenderFemale[x])
        Y_Female = np.array(dataByGenderFemale[y])
        coefficientsFemale, pcov = curve_fit(expFunction, X_Female, Y_Female)
        
        X_Male = np.array(dataByGenderMale[x])
        Y_Male = np.array(dataByGenderMale[y])
        coefficientsMale, pcov = curve_fit(expFunction, X_Male, Y_Male)
        
        self.aF = coefficientsFemale[0]
        self.cF = coefficientsFemale[1]
        
        self.aM = coefficientsMale[0]
        self.cM = coefficientsMale[1]
        
        self.type = "exponentialByAge"
        
    def predict(self, x, female = None):
        return(expFunction(x, self.aF, self.cF) if female == 1 else expFunction(x, self.aM, self.cM))

'''
Class parabolicFeature:

Attributes
----------
a: float
    coefficient a of the equation: a*X**2 + b*x + c
c: float
    coefficient c of the equation: a*X**2 + b*x + c
c: float
    coefficient c of the equation: a*X**2 + b*x + c
    
Functions
----------
__init__: Fit and save the coefficient a and c from the x and y coordinates that belong to the pandas dataframe "data" 

predict: Use the fitted equation to predict the y value using the x parameter

'''
class parabolicFeature:
    # Exponential features have the following formula: a*np.log(x) + c
    def __init__(self, data, x, y):
        self.type = "parabolic"
        X = np.array(data[x])
        Y = np.array(data[y])
        coefficients, pcov = curve_fit(parabolicFunction, X, Y)
        self.a = coefficients[0]
        self.b = coefficients[1]
        self.c = coefficients[1]
        
    def predict(self, x, female = None):
        return(parabolicFunction(x, self.a, self.c))

    
'''
Class binaryFeature:

Attributes
----------
TrueCoeff: float
    coefficient associeted with true value x
TrueCoeff: float
    coefficient associeted with false value x
    
Functions
----------
__init__: Save the coefficients ase median of the y values of the x binary subdivision of "data" 

predict: Return the correct coefficient

'''
class binaryFeature:
    # Exponential features have the following formula: a*np.log(x) + c
    def __init__(self, data, x, y):
        self.TrueCoeff = data[data[x]==1][y].median()
        self.FalseCoeff = data[data[x]==0][y].median()
        self.type = "binary"
        
    def predict(self, x, female = None):
        return(self.TrueCoeff if x == 1 else self.FalseCoeff)
    
    
'''
Class binaryFeatureByAge:

Attributes
----------
TrueCoeffMale: float
    coefficient associeted with true value x with sex Male
TrueCoeffMale: float
    coefficient associeted with false value x with sex Male
TrueCoeffFemale: float
    coefficient associeted with true value x with sex Female
TrueCoeffFemale: float
    coefficient associeted with false value x with sex Female
    
Functions
----------
__init__: Save the coefficients ase median of the y values of the x binary subdivision of "data" 

predict: Return the correct coefficient

'''
class binaryFeatureBySex:
    # Exponential features have the following formula: a*np.log(x) + c
    def __init__(self, data, x, y):
        dataByGenderFemale = data[data["Female"]==1]
        dataByGenderMale = data[data["Female"]==0]
        
        self.TrueCoeffFemale = dataByGenderFemale[dataByGenderFemale[x]==1][y].median()
        self.FalseCoeffFemale = dataByGenderFemale[dataByGenderFemale[x]==0][y].median()
        self.TrueCoeffMale = dataByGenderMale[dataByGenderMale[x]==1][y].median()
        self.FalseCoeffMale = dataByGenderMale[dataByGenderMale[x]==0][y].median()
        self.type = "binaryByAge"
        
    def predict(self, x, female = None):
        if female:
            return(self.TrueCoeffFemale if x == 1 else self.FalseCoeffFemale)
        else:
            return(self.TrueCoeffMale if x == 1 else self.FalseCoeffMale)
            
'''

Class SHAP Model:

Attributes
----------
name: string
    String with the name of the model
    
featuresModels: dict
    Dictionary with all the features fitted used in the model
    The features are objects (look above for more info)

Functions
----------
__init__: Initialize the model with the model name, the baseline, the empty fittedFeaturesDict 
            and the empty featuresContribution dict

fitExpFeature: Fit and add to the fitted features dictionary an object with the coefficients of an exponential feature

fitBinaryFeature: Fit and add to the fitted features dictionary an object with the coefficients of binary classifier

predict: require as input the dictionary with the patient features. The output is the probability 
            and a dictionary with each feature delta contribution 

fittedFeaturesContribution: require as input the dictionary with all the feature contribution to the model performance and 
                            generate the self dictionary with the contributions of the fitted features in the model
'''
class SHAPmodel:
    def __init__(self, model_name, baseline):
        self.name = model_name
        self.baseline = baseline
        self.fittedFeatures = {}
        self.featuresContributions = {}
        
    def fitLinearFeature(self, name, data, x, y):
        self.fittedFeatures[name] = (linearFeature(data, x, y))
        
    def fitExpFeature(self, name, data, x, y):
        self.fittedFeatures[name] = (expFeature(data, x, y))
        
    def fitExpFeatureBySex(self, name, data, x, y):
        self.fittedFeatures[name] = (expFeatureBySex(data, x, y))
        
    def fitBinaryFeature(self, name, data, x, y):
        self.fittedFeatures[name] = (binaryFeature(data, x, y))
        
    def fitBinaryFeatureBySex(self, name, data, x, y):
        self.fittedFeatures[name] = (binaryFeatureBySex(data, x, y))
        
    def predict(self, x_features, verbose = False):
        # Definisco il dizionari con i contributi di ciascuna feature
        features_delta = {}
        positive_features_delta = {}
        negative_features_delta = {}
        
        # Extract the info about patient sex
        female = x_features['Female']
        # Esploro tutte le features salvate nel modello
        for feature_name in list(self.fittedFeatures.keys()):
            # Check if the feature in the model is also present in the features passed
            if feature_name in x_features:
                # If the feature is missing or its value is null the contribution is zero
                if ((x_features[feature_name]==None) or np.isnan(x_features[feature_name])):
                    features_delta[feature_name] = 0
                else:
                    features_delta[feature_name] = self.fittedFeatures[feature_name].predict(x_features[feature_name], female)
                    # Extract and save only the features with a positive delta
                    if self.fittedFeatures[feature_name].predict(x_features[feature_name]) > 0:
                        positive_features_delta[feature_name] = self.fittedFeatures[feature_name].predict(x_features[feature_name], female)
                    # Extract and save only the features with a negative delta
                    if self.fittedFeatures[feature_name].predict(x_features[feature_name]) < 0 :
                        negative_features_delta[feature_name] =  self.fittedFeatures[feature_name].predict(x_features[feature_name], female)
            else:
                features_delta[feature_name] = 0
                if verbose:
                    print("The feature is not specified in the input dict: ", feature_name)
                    
        # When all the contributions are ready I can compute the probability
        pred_proba = self.baseline
        for feature_name in list(features_delta.keys()):
            pred_proba += features_delta[feature_name]
            
        return(pred_proba, features_delta, positive_features_delta, negative_features_delta)
    
    def fittedFeaturesContribution(self, all_features_contributions):
        # Esploro tutte le features salvate nel modello
        for feature_name in list(self.fittedFeatures.keys()):
            self.featuresContributions[feature_name] = all_features_contributions[feature_name]

"""## Model Construction"""

sX_val_concat_barc = deepcopy(X_val_barc)
# Reset Indexes to allow concatenation
sX_val_concat_barc.reset_index(inplace=True, drop = True)
shap_complete_df_barc = pd.concat([shap_df_barc, sX_val_concat_barc], axis = 1)

sX_val_concat_death = deepcopy(X_val_death)
# Reset Indexes to allow concatenation
sX_val_concat_death.reset_index(inplace=True, drop = True)
shap_complete_df_death = pd.concat([shap_df_death, sX_val_concat_death], axis = 1)

"""FEATURES VISUALIZATION EXAMPLES"""

# Example FOr ExpFit Visualization
'''
    c_AGE, i_AGE = shapScatterExpFit(shap_complete_df_barc, "Age", "Age_SHAP", "Female", ["Age", "Average Age IMPACT", "Outcome"], "SHAP ScatterPlot: Age", 
                           facet = False, 
                           savePNG = False,
                           saveHTML = False,
                           plot = True,
                           directory = "/content/drive/MyDrive/ASP/ML_models/Karim/DeepLearning/SHAP_results/", 
                           filename = "ScatterAge")
                           
   c_creatinine, i_creatinine = shapScatterParabolicFit(shap_complete_df_barc, "creatinine", "creatinine_SHAP", "Female", ["eGFR (MDRD)", "Average eGFR (MDRD) Impact", "Outcome"], "SHAP ScatterPlot: eGFR (MDRD)", 
                          facet = False, 
                          savePNG = False,
                          saveHTML = False,
                          plot = True,
                          directory = "/content/drive/MyDrive/ASP/ML_models/Karim/DeepLearning/SHAP_results/", 
                          filename = "Scatter_eGFR_(MDRD)")
'''

"""## MODEL CONSTRUCTION"""

#+------------------------------------------------------------------------------------------------------+
#|                             DEATH MODEL GENERATION & INIZIALIZATION                                   |
#+------------------------------------------------------------------------------------------------------+
# Model Inizialization
ShapModelDeath = SHAPmodel("Model Death", baseline_death)

# Model Fitting
dataset = shap_complete_df_death

# Numerical Features
ShapModelDeath.fitLinearFeature(name = "LVEF", data = dataset, x = "LVEF", y = "LVEF_SHAP")
ShapModelDeath.fitLinearFeature(name = "Age", data = dataset, x = "Age", y = "Age_SHAP")
ShapModelDeath.fitLinearFeature(name = "Hb", data = dataset, x = "Hb", y = "Hb_SHAP")
#ShapModelDeath.fitExpFeature(name = "creatinine", data = dataset, x = "creatinine", y = "creatinine_SHAP")
ShapModelDeath.fitExpFeature(name = "eGFR (MDRD)", data = dataset, x = "eGFR (MDRD)", y = "eGFR (MDRD)_SHAP")

# Categorical 
ShapModelDeath.fitBinaryFeature(name = "Complete_revasc", data = shap_complete_df_death, x = "Complete_revasc", y = "Complete_revasc_SHAP")
ShapModelDeath.fitBinaryFeature(name = "Diabetes mellitus (both)", data = shap_complete_df_death, x = "Diabetes mellitus (both)", y = "Diabetes mellitus (both)_SHAP")
ShapModelDeath.fitBinaryFeature(name = "Malignancy", data = shap_complete_df_death, x = "Malignancy", y = "Malignancy_SHAP")
ShapModelDeath.fitBinaryFeature(name = "PPI", data = shap_complete_df_death, x = "PPI", y = "PPI_SHAP")
ShapModelDeath.fitBinaryFeature(name = "BB", data = shap_complete_df_death, x = "BB", y = "BB_SHAP")
ShapModelDeath.fitBinaryFeature(name = "Stent_DES", data = shap_complete_df_death, x = "Stent_DES", y = "Stent_DES_SHAP")
ShapModelDeath.fitBinaryFeature(name = "ACEiARB", data = shap_complete_df_death, x = "ACEiARB", y = "ACEiARB_SHAP")
ShapModelDeath.fitBinaryFeature(name = "hyperlipidemia", data = shap_complete_df_death, x = "hyperlipidemia", y = "hyperlipidemia_SHAP")
ShapModelDeath.fitBinaryFeature(name = "CKD (eGFR <60)", data = shap_complete_df_death, x = "CKD (eGFR <60)", y = "CKD (eGFR <60)")

#ShapModelDeath.fitBinaryFeature(name = "VascularAccess (0=radial,1=femoral)", data = shap_complete_df_death, x = "VascularAccess (0=radial,1=femoral)", y = "VascularAccess (0=radial,1=femoral)_SHAP")
#ShapModelDeath.fitBinaryFeature(name = "Multivessel", data = shap_complete_df_death, x = "Multivessel", y = "Multivessel_SHAP")
#ShapModelDeath.fitBinaryFeature(name = "UA-nstemi", data = shap_complete_df_death, x = "UA-nstemi", y = "UA-nstemi_SHAP")
#ShapModelDeath.fitBinaryFeature(name = "PriorAMI", data = shap_complete_df_death, x = "PriorAMI", y = "PriorAMI_SHAP")
#ShapModelDeath.fitBinaryFeature(name = "Female", data = shap_complete_df_death, x = "Female", y = "Female_SHAP")
#ShapModelDeath.fitBinaryFeature(name = "hypertension", data = shap_complete_df_death, x = "hypertension", y = "hypertension_SHAP")
#ShapModelDeath.fitBinaryFeature(name = "PriorStroke", data = shap_complete_df_death, x = "PriorStroke", y = "PriorStroke_SHAP")
#ShapModelDeath.fitBinaryFeature(name = "PriorBleeding", data = shap_complete_df_death, x = "PriorBleeding", y = "PriorBleeding_SHAP")

# Relevant Features Contribution
ShapModelDeath.fittedFeaturesContribution(featureImportance_death)

#+------------------------------------------------------------------------------------------------------+
#|                             BARC MODEL GENERATION & INIZIALIZATION                                   |
#+------------------------------------------------------------------------------------------------------+
# Model Inizialization
ShapModelBarc = SHAPmodel("Model Barc", baseline_barc)

# Model Fitting
dataset = shap_complete_df_barc

# Numerical Features
ShapModelBarc.fitExpFeature(name = "Age", data = dataset, x = "Age", y = "Age_SHAP")
ShapModelBarc.fitExpFeature(name = "LVEF", data = dataset, x = "LVEF", y = "LVEF_SHAP")
ShapModelBarc.fitExpFeatureBySex(name = "Hb", data = dataset, x = "Hb", y = "Hb_SHAP")
#ShapModelBarc.fitExpFeature(name = "creatinine", data = dataset, x = "creatinine", y = "creatinine_SHAP")
ShapModelBarc.fitExpFeature(name = "eGFR (MDRD)", data = dataset, x = "eGFR (MDRD)", y = "eGFR (MDRD)_SHAP")

# Categorical 
ShapModelBarc.fitBinaryFeature(name = "VascularAccess (0=radial,1=femoral)", data = shap_complete_df_barc, x = "VascularAccess (0=radial,1=femoral)", y = "VascularAccess (0=radial,1=femoral)_SHAP")
ShapModelBarc.fitBinaryFeature(name = "Multivessel", data = shap_complete_df_barc, x = "Multivessel", y = "Multivessel_SHAP")
ShapModelBarc.fitBinaryFeature(name = "Stent_DES", data = shap_complete_df_barc, x = "Stent_DES", y = "Stent_DES_SHAP")
ShapModelBarc.fitBinaryFeature(name = "PPI", data = shap_complete_df_barc, x = "PPI", y = "PPI_SHAP")
ShapModelBarc.fitBinaryFeature(name = "UA-nstemi", data = shap_complete_df_barc, x = "UA-nstemi", y = "UA-nstemi_SHAP")
ShapModelBarc.fitBinaryFeature(name = "Complete_revasc", data = shap_complete_df_barc, x = "Complete_revasc", y = "Complete_revasc_SHAP")
ShapModelBarc.fitBinaryFeature(name = "PriorAMI", data = shap_complete_df_barc, x = "PriorAMI", y = "PriorAMI_SHAP")
ShapModelBarc.fitBinaryFeature(name = "ACEiARB", data = shap_complete_df_barc, x = "ACEiARB", y = "ACEiARB_SHAP")
ShapModelBarc.fitBinaryFeature(name = "hyperlipidemia", data = shap_complete_df_barc, x = "hyperlipidemia", y = "hyperlipidemia_SHAP")
ShapModelBarc.fitBinaryFeature(name = "Diabetes mellitus (both)", data = shap_complete_df_barc, x = "Diabetes mellitus (both)", y = "Diabetes mellitus (both)_SHAP")
ShapModelBarc.fitBinaryFeature(name = "Female", data = shap_complete_df_barc, x = "Female", y = "Female_SHAP")
ShapModelBarc.fitBinaryFeature(name = "hypertension", data = shap_complete_df_barc, x = "hypertension", y = "hypertension_SHAP")
ShapModelBarc.fitBinaryFeature(name = "PriorStroke", data = shap_complete_df_barc, x = "PriorStroke", y = "PriorStroke_SHAP")
ShapModelBarc.fitBinaryFeature(name = "PriorBleeding", data = shap_complete_df_barc, x = "PriorBleeding", y = "PriorBleeding_SHAP")

# Relevant Features Contribution
ShapModelBarc.fittedFeaturesContribution(featureImportance_barc)


# Model computation
#ShapModelBarc.fittedFeatures["Hb"].predict(6.4)
#patient_1 = {'Hb': 6.5, 'Age': 65, 'LVEF': 60, 'creatinine': 7, 'eGFR (MDRD)': 100, 
#             'Stent_DES': 1, 'hypertension':1, 'PriorStroke': 1, 'PriorBleeding': 1 }
#ShapModelBarc.predict(patient_1, verbose = True)

#ShapModelBarc.featuresContributions

### New Probability Score Computation

'''pred_proba_test = []
for index in range(len(X_test_death)):
    patient = dict(X_test_death.iloc[index])
    #print(patient)
    pred_proba_test_patient, ftrsDelta, positiveFtrsDelta, negativeFtrsDelta  = ShapModelDeath.predict(patient)
    pred_proba_test.append(pred_proba_test_patient)

pred_proba_test = np.array(pred_proba_test)
# Prediction TEST
y_pred_test = np.where(pred_proba_test > 0.5, 1,0)
accuracy_test = accuracy_score(y_test_death, y_pred_test).round(4)
f1_test = f1_score(y_test_death, y_pred_test, average='macro').round(4)

# Plot and save Prediction
f2_test, auc_test = plotPerformances(y_pred_test, pred_proba_test, y_test_death, 
                                     model_name = "Test_DEATH",
                                     matrixLabels=["D", "ND"], title = "Test DEATH", norm = False, printMetrics = True)'''

'''pred_proba_test = []
for index in range(len(X_test_barc)):
    patient = dict(X_test_barc.iloc[index])
    #print(patient)
    pred_proba_test_patient, ftrsDelta, positiveFtrsDelta, negativeFtrsDelta  = ShapModelBarc.predict(patient)
    pred_proba_test.append(pred_proba_test_patient)

pred_proba_test = np.array(pred_proba_test)
# Prediction TEST
y_pred_test = np.where(pred_proba_test > 0.5, 1,0)
accuracy_test = accuracy_score(y_test_barc, y_pred_test).round(4)
f1_test = f1_score(y_test_barc, y_pred_test, average='macro').round(4)

# Plot and save Prediction
f2_test, auc_test = plotPerformances(y_pred_test, pred_proba_test, y_test_barc, 
                                     model_name = "Test_BARC",
                                     matrixLabels=["B", "NB"], title = "Test BARC", norm = False, printMetrics = True)'''



"""# DASH APP

## Install Dependecies
"""

#Installing specific packages.
#!pip install dash==2.0.0
#!pip install -q jupyter_dash==0.3.0

"""## Import Libraries"""

#Importing the libraries for live plotting
import base64
import io
from jupyter_dash import JupyterDash
from dash import html,  dash_table
from dash import dcc
import dash
from dash.dependencies import Input, Output, State
external_stylesheets =  ['https://codepen.io/chriddyp/pen/bWLwgP.css'] #[dbc.themes.DARKLY]

"""## App Functions And Variables"""



#+======================================================================================================+
#|                                             FUNCTIONS                                                |
#+======================================================================================================+
#+------------------------------------------------------------------------------------------------------+
#|                            Data Parser to upload file in csv and xls                                 |
#+------------------------------------------------------------------------------------------------------+
def parse_contents(contents, filename):
    content_type, content_string = contents.split(',')
    decoded = base64.b64decode(content_string)
    if 'csv' in filename:
        # Assume that the user uploaded a CSV file
        return pd.read_csv(
            io.StringIO(decoded.decode('utf-8')))
    elif 'xls' in filename:
        # Assume that the user uploaded an excel file
        return pd.read_excel(io.BytesIO(decoded))
    
#+------------------------------------------------------------------------------------------------------+
#|                              Image Encoder for the ASP and Y4A Logo                                  |
#+------------------------------------------------------------------------------------------------------+
image_filename = projectRoot + 'images/AspLogo.png' # replace with your own image
image_filenameY4A = projectRoot + 'images/Y4A_logo.png' # replace with your own image

aspLogo = 'data:image/png;base64,{}'.format(
                                    base64.b64encode(
                                        open(
                                            image_filename, 'rb'
                                        ).read()
                                    ).decode()
                                )

y4aLogo = 'data:image/png;base64,{}'.format(
                                    base64.b64encode(
                                        open(
                                            image_filenameY4A, 'rb'
                                        ).read()
                                    ).decode()
                                )


#+======================================================================================================+
#|                                PLOTTING FUNCTIONS REGRESSION LINES                                   |
#+======================================================================================================+
#+------------------------------------------------------------------------------------------------------+
#|                                   Scatter Plot + Regression                                          |
#+------------------------------------------------------------------------------------------------------+

import plotly.graph_objects as go
import statsmodels.api as sm
from sklearn.linear_model import LinearRegression

def shapScatterColor(data, x, y, colorData, labels, title, savePNG = False, saveHTML = False, directory = "", filename = "",  myLVEF =60):
    # Regression
    X = data[x]
    Y = data[y]

    # Adding a costant
    X = sm.add_constant(X)

    # Fit the model
    regModel = sm.OLS(Y.astype(float), X.astype(float)).fit()
    x_range = np.linspace(data[x].min(), data[x].max(), 100)
    y_range = regModel.predict(sm.add_constant(x_range))

    # Confidence
    alpha = .05

    predictions = regModel.get_prediction(sm.add_constant(x_range)).summary_frame(alpha)

    plotlyfig = px.scatter(data, x=x, y=y, template="plotly_white",
            color = colorData, 
            color_discrete_sequence = ["#4D8EBE"], #["#95BDDA", "#5A98C4", "#356E97", "#1B374B"],
            color_continuous_scale= ["#356E97", "#E3E3E3", "#851E2F"],

            #symbol = colorData,
            #trendline="ols",
            title = "<b>"+title+"</b><br><br><br><br>",#➊ Color: <i>"+labels[2]+"</i>",
            opacity=0.75,
            labels={
                x: labels[0],
                y: labels[1],
                colorData: labels[2]
            })  

    plotlyfig.update_traces(marker=dict(size=4))
    plotlyfig.add_traces(go.Scatter(x=x_range, y=y_range, name='Regression Fit', line_color = "#356E97"))

    x_range = list(x_range)
    x_range_rev = x_range[::-1]
    y1_upper = list(predictions['mean_ci_upper'])
    y1_lower = list(predictions['mean_ci_lower'])
    y1_lower = y1_lower[::-1]

    plotlyfig.add_traces(go.Scatter(
        x=x_range+x_range_rev,
        y=y1_upper+y1_lower,
        fill='toself',
        fillcolor='rgba(0,100,80,0.1)',
        line_color='rgba(255,255,255,0.0)',
        name='Confidence Interval',))

    myLVEFRisk = regModel.predict([1.,myLVEF])
    plotlyfig.add_traces(go.Scatter(
      mode = "markers",
      line_color="#0B161E",
      marker_line_width=1, marker_size=12,
      x=np.array([myLVEF]),
      y=myLVEFRisk,
      name='Patient Indicator',
      marker=dict(
        symbol = 6,
        size=16,
        cmax=max(list(data[colorData])),
        cmin=min(list(data[colorData])),
        color=myLVEFRisk+0.01,
        colorscale=["#356E97", "#E3E3E3", "#851E2F"],
    )))
  


    plotlyfig.update_layout(
      #autosize=False,
      #width=1100,
      #height=600,
      legend=dict(
           orientation="h",
           yanchor="bottom",
           y=1.0,
           xanchor="right",
           x=1.1))

    #plotlyfig.show()
    #print("Regression Coefficient: \t\t", regModel.coef_)
    #print("Regression Intercept: \t\t", regModel.intercept_)

    if savePNG:
        print("Saved PNG: ", str(directory+filename+".png"))
        pio.write_image(plotlyfig, str(directory+filename+".png"), scale=4)

    if saveHTML:
        print("Saved HTML: ", str(directory+filename+".html"))
        plotlyfig.write_html(str(directory+filename+".html"))

    return(plotlyfig)
#+------------------------------------------------------------------------------------------------------+
#|                                   Scatter Plot + Fitting                                             |
#+------------------------------------------------------------------------------------------------------+

def shapScatterCurveFit(data, x, y, colorData, labels, title, fitType, myLevel = 60):
    # Exp Fitting
    if fitType == "exponential":
        X = np.array(data[x])
        Y = np.array(data[y])
        popt, pcov = curve_fit(expFunction, X, Y)

        x_range = np.linspace(X.min(), X.max(), 100)
        y_range = expFunction(x_range, *popt)
    elif fitType == "linear": 
        X = np.array(data[x])
        Y = np.array(data[y])
        popt, pcov = curve_fit(linearFunction, X, Y)

        x_range = np.linspace(X.min(), X.max(), 100)
        y_range = linearFunction(x_range, *popt)

    plotlyfig = px.scatter(data, x=x, y=y, template="plotly_white",
            color = colorData, 
            color_discrete_sequence = ["#4D8EBE"], #["#95BDDA", "#5A98C4", "#356E97", "#1B374B"],
            color_continuous_scale= ["#356E97", "#E3E3E3", "#851E2F"],

            #symbol = colorData,
            #trendline="ols",
            title = "<b>"+title+"</b><br><br><br><br>",#➊ Color: <i>"+labels[2]+"</i>",
            opacity=0.45,
            labels={
                x: labels[0],
                y: labels[1],
                colorData: labels[2]
            })  

    plotlyfig.update_traces(marker=dict(size=4))
    plotlyfig.add_traces(go.Scatter(x=x_range, y=y_range, name='Regression Fit', line_color = "#356E97"))

    myLevelRisk = expFunction(myLevel, *popt)
    plotlyfig.add_traces(go.Scatter(
      mode = "markers",
      line_color="#0B161E",
      marker_line_width=1, marker_size=12,
      x=np.array([myLevel]),
      y=np.array([myLevelRisk]),
      name='Patient Indicator',
      marker=dict(
        symbol = 6,
        size=16,
        cmax=max(list(data[colorData])),
        cmin=min(list(data[colorData])),
        color=myLevelRisk+0.01,
        colorscale=["#356E97", "#E3E3E3", "#851E2F"],
    )))
  
    

    plotlyfig.update_layout(
      legend=dict(
           orientation="h",
           yanchor="bottom",
           y=1.0,
           xanchor="right",
           x=1.1))
    
    plotlyfig.data = (plotlyfig.data[2], plotlyfig.data[1], plotlyfig.data[0])

    return(plotlyfig)
#+======================================================================================================+
#|                                PLOTTING FUNCTIONS SINGLE PREDICTION                                  |
#+======================================================================================================+
#+------------------------------------------------------------------------------------------------------+
#|                                 Pie Chart for risk Prediction BARC                                   |
#+------------------------------------------------------------------------------------------------------+
def riskPieChartBarc(pred_proba_test_patient):
    modelRisk = round(pred_proba_test_patient*100,2)
    df = pd.DataFrame.from_dict({"Prediction Value": [modelRisk], "Class": ["Model Output"]})
    piePalette = ["#851E2F",'#356E97']
    fig = go.Figure()
    
    fig.add_traces(go.Scatter(x=df["Class"], y=df["Prediction Value"],
                                mode='markers',
                                name='Model Output',
                                line = dict(color='black', width=2),
                                marker=dict(size=18,
                                            color=list(df["Prediction Value"]),
                                            cmax=60.,#max(list(waterfall["Value"])),
                                            cmin=45.,#min(list(waterfall["Value"])),
                                            colorscale=['#356E77', "#851E2F"],
                                            symbol = 200,
                                            line=dict(width=1,color='Black'),
                                            colorbar=dict(
                                                tick0=0,
                                                #dtick=1
                                            ),
                                            )))
    
    fig.add_traces(go.Scatter(x=[df["Class"].iloc[-1]], y=[df["Prediction Value"].iloc[-1]+1],
                                mode='text',
                                name = "Model Output", 
                                text = [str(str(round(modelRisk,2))+"%")],
                                textposition="top center",
                                textfont=dict(
                                    size=16,
                                    color="Black"))
                    )
    


    fig.update_layout(title = "<b>Model Probability Output:</b>",
                        template="plotly_white", 
                        margin=dict(r=0),
                        yaxis_range=[40,60],
                        legend=dict(
                            orientation="h",
                            yanchor="top",
                            y=-0.4,
                            xanchor="center",
                            x=0.5))
    return fig

#+------------------------------------------------------------------------------------------------------+
#|                       Pie Chart for Calibrated risk Prediction BARC                                  |
#+------------------------------------------------------------------------------------------------------+
def calibratedRiskPieChartBarc(pred_proba_test_patient, iso_reg):
    risk = iso_reg.predict(np.expand_dims(pred_proba_test_patient, axis=0))
    risk = round(risk[0]*100,4)
    df = pd.DataFrame.from_dict({"Prediction Value": [risk], "Class": ["Predicted Risk"]})
    piePalette = ["#851E2F",'#356E77']
    

    fig = go.Figure()
    
    fig.add_traces(go.Scatter(x=df["Class"], y=df["Prediction Value"],
                                mode='markers',
                                name='Predicted Risk',
                                line = dict(color='black', width=2),
                                marker=dict(size=18,
                                            color=list(df["Prediction Value"]),
                                            cmax=19.,#max(list(waterfall["Value"])),
                                            cmin=0.,#min(list(waterfall["Value"])),
                                            colorscale=['#356E77', "#851E2F"],
                                            symbol = 204,
                                            line=dict(width=1,color='Black'),
                                            colorbar=dict(
                                                tick0=0,
                                                #dtick=1
                                            ),
                                            )))
    
    fig.add_traces(go.Scatter(x=[df["Class"].iloc[-1]], y=[df["Prediction Value"].iloc[-1]+1],
                                mode='text',
                                name = "Final Risk", 
                                text = [str(str(round(risk,2))+"%")],
                                textposition="top center",
                                textfont=dict(
                                    size=16,
                                    color="Black"))
                    )
    


    fig.update_layout(title = "<b>Predicted Risk:</b>",
                        template="plotly_white", 
                        margin=dict(r=0),
                        yaxis_range=[0,20],
                        legend=dict(
                            orientation="h",
                            yanchor="top",
                            y=-0.4,
                            xanchor="center",
                            x=0.5))
    return fig

#+------------------------------------------------------------------------------------------------------+
#|                                 Pie Chart for risk Prediction DEATH                                   |
#+------------------------------------------------------------------------------------------------------+
def riskPieChartDeath(pred_proba_test_patient):
    modelRisk = round(pred_proba_test_patient*100,2)
    df = pd.DataFrame.from_dict({"Prediction Value": [modelRisk], "Class": ["Model Output"]})
    piePalette = ["#851E2F",'#356E97']
    fig = go.Figure()
    
    fig.add_traces(go.Scatter(x=df["Class"], y=df["Prediction Value"],
                                mode='markers',
                                name='Model Output',
                                line = dict(color='black', width=2),
                                marker=dict(size=18,
                                            color=list(df["Prediction Value"]),
                                            cmax=100.,#max(list(waterfall["Value"])),
                                            cmin=0.,#min(list(waterfall["Value"])),
                                            colorscale=['#356E77', "#851E2F"],
                                            symbol = 200,
                                            line=dict(width=1,color='Black'),
                                            colorbar=dict(
                                                tick0=0,
                                                #dtick=1
                                            ),
                                            )))
    
    fig.add_traces(go.Scatter(x=[df["Class"].iloc[-1]], y=[df["Prediction Value"].iloc[-1]+4],
                                mode='text',
                                name = "Model Output", 
                                text = [str(str(round(modelRisk,2))+"%")],
                                textposition="top center",
                                textfont=dict(
                                    size=16,
                                    color="Black"))
                    )
    


    fig.update_layout(title = "<b>Model Probability Output:</b>",
                        template="plotly_white", 
                        margin=dict(r=0),
                        yaxis_range=[0,100],
                        legend=dict(
                            orientation="h",
                            yanchor="top",
                            y=-0.4,
                            xanchor="center",
                            x=0.5))
    return fig

#+------------------------------------------------------------------------------------------------------+
#|                       Pie Chart for Calibrated risk Prediction DEATH                                 |
#+------------------------------------------------------------------------------------------------------+
def calibratedRiskPieChartDeath(pred_proba_test_patient, iso_reg):
    risk = iso_reg.predict(np.expand_dims(pred_proba_test_patient, axis=0))
    risk = round(risk[0]*100,4)
    df = pd.DataFrame.from_dict({"Prediction Value": [risk], "Class": ["Predicted Risk"]})
    piePalette = ["#851E2F",'#356E77']
    

    fig = go.Figure()
    
    fig.add_traces(go.Scatter(x=df["Class"], y=df["Prediction Value"],
                                mode='markers',
                                name='Predicted Risk',
                                line = dict(color='black', width=2),
                                marker=dict(size=18,
                                            color=list(df["Prediction Value"]),
                                            cmax=100.,#max(list(waterfall["Value"])),
                                            cmin=0.,#min(list(waterfall["Value"])),
                                            colorscale=['#356E77', "#851E2F"],
                                            symbol = 204,
                                            line=dict(width=1,color='Black'),
                                            colorbar=dict(
                                                tick0=0,
                                                #dtick=1
                                            ),
                                            )))
    
    fig.add_traces(go.Scatter(x=[df["Class"].iloc[-1]], y=[df["Prediction Value"].iloc[-1]+4],
                                mode='text',
                                name = "Final Risk", 
                                text = [str(str(round(risk,2))+"%")],
                                textposition="top center",
                                textfont=dict(
                                    size=16,
                                    color="Black"))
                    )
    


    fig.update_layout(title = "<b>Predicted Risk:</b>",
                        template="plotly_white", 
                        margin=dict(r=0),
                        yaxis_range=[0,100],
                        legend=dict(
                            orientation="h",
                            yanchor="top",
                            y=-0.4,
                            xanchor="center",
                            x=0.5))
    return fig


#+------------------------------------------------------------------------------------------------------+
#|                            Sun Burst Graph For Delta Risk Contribution                               |
#+------------------------------------------------------------------------------------------------------+
def sunBurstPredGraph(negativeContrib, positiveContrib):    
    featuresName = list(negativeContrib.columns) + list(positiveContrib.columns)
    contributionType = ["Negative"]*len(list(negativeContrib.columns)) + ["Positive"]*len(list(positiveContrib.columns))
    deltaRiskSum = ["Abs Delta Risk"]*len(list(negativeContrib.columns)) +  ["Abs Delta Risk"]*len(list(positiveContrib.columns))
    SHAPValues =list(abs(round(negativeContrib.iloc[0],4))) + list(abs(round(positiveContrib.iloc[0],4)))

    df = pd.DataFrame(
        dict(featuresName=featuresName, contributionType=contributionType, deltaRiskSum=deltaRiskSum, SHAPValues=SHAPValues)
    )
    figPred = px.sunburst(df, path=['deltaRiskSum', 'contributionType', 'featuresName'], values='SHAPValues', 
                          color='contributionType', 
                          color_discrete_map={'(?)':'white', 'Negative':"#356E97", 'Positive':"#851E2F"},
                          title = "<b>SunBurst</b><br>➊ Color: <i>Positive Contribution vs Negative</i>")
    figPred.update_layout(margin=dict(b=10),)
    return(figPred)

#+------------------------------------------------------------------------------------------------------+
#|                            Sun Burst Graph For Feature Relevance Analysis                            |
#+------------------------------------------------------------------------------------------------------+
def sunBurstContribGraph(negativeContrib, positiveContrib, SHAPmodel):   
    used = []
    used_values = []
    missing = []
    missing_values = []
    for feature in list(SHAPmodel.featuresContributions.keys()):
      if feature in list(negativeContrib.columns) + list(positiveContrib.columns):
        used.append(feature)
        used_values.append(SHAPmodel.featuresContributions[feature])
      else:
        missing.append(feature)
        missing_values.append(SHAPmodel.featuresContributions[feature])

    featuresName = used + missing
    contributionType = ["Used"]*len(used) + ["Missing"]*len(missing)
    modelAccuracy = ["Model Accuracy"]*len(used) +  ["Model Accuracy"]*len(missing)
    ContributionValues = used_values + missing_values

    df = pd.DataFrame(
        dict(featuresName=featuresName, contributionType=contributionType, modelAccuracy=modelAccuracy, ContributionValues=ContributionValues)
    )
    figContrib = px.sunburst(df, path=['modelAccuracy', 'contributionType', 'featuresName'], values='ContributionValues', 
                      color='contributionType', 
                      color_discrete_map={'(?)':'white', 'Used':"#75A465", 'Missing':"#CEC3C1"},
                      title = "<b>SunBurst</b><br>➊ Color: <i>Contribution of Used Variables vs Missing</i>",)
    figContrib.update_layout(margin=dict(b=10),)
    return figContrib, used, used_values, missing, missing_values

#+------------------------------------------------------------------------------------------------------+
#|                                             "Waterfall" Plot                                         |
#+------------------------------------------------------------------------------------------------------+
def waterFallGraph(contribution_dict):
    # Waterfall feature name
    wf_feature = ["Baseline"]
    # Waterfall feature conribution
    wf_value = [baseline_barc]
    # Waterfall feature type
    wf_type = ["Baseline"]
    # Cumulative prediction
    cumulativePred = baseline_barc
    
    for contrib in list(contribution_dict.keys()):
      wf_feature.append(contrib)
      cumulativePred = cumulativePred + contribution_dict[contrib]
      wf_value.append(cumulativePred)
      if contribution_dict[contrib] > 0:
          wf_type.append("Positive")
      elif contribution_dict[contrib] < 0:
          wf_type.append("Negative")
      else:
          wf_type.append("Null")

    waterfall = {"Feature": wf_feature, "Value": wf_value, "Type": wf_type}
    waterfall = pd.DataFrame.from_dict(waterfall)

    figWF = go.Figure()
    figWF.add_traces(go.Scatter(x=waterfall["Feature"], y=waterfall["Value"],
                                mode='lines+markers',
                                name = "Delta Risk", 
                                line = dict(color='black', width=2),
                                marker=dict(size=6,
                                            color="black")))

    figWF.add_traces(go.Scatter(x=waterfall[waterfall["Type"] == "Positive"]["Feature"], y=waterfall[waterfall["Type"] == "Positive"]["Value"],
                                mode='markers',
                                name = "Positive Contribution", 
                                line = dict(color='black', width=2),
                                marker=dict(size=16,
                                            color=list(waterfall[waterfall["Type"] == "Positive"]["Value"]),
                                            cmax=1.,#max(list(waterfall["Value"])),
                                            cmin=0.,#min(list(waterfall["Value"])),
                                            colorscale=["#E3E3E3", "#851E2F"],
                                            symbol = 5,
                                            line=dict(width=1,color='Black')
                                            )))
    figWF.add_traces(go.Scatter(x=waterfall[waterfall["Type"] == "Null"]["Feature"], y=waterfall[waterfall["Type"] == "Null"]["Value"],
                            mode='markers',
                            name = "Negative Contribution", 
                            marker=dict(size=6,
                                        color="#E3E3E3",
                                        symbol = 0,
                                        line=dict(width=1,color='Black')
                                        )))
    figWF.add_traces(go.Scatter(x=waterfall[waterfall["Type"] == "Negative"]["Feature"], y=waterfall[waterfall["Type"] == "Negative"]["Value"],
                                mode='markers',
                                name = "Negative Contribution", 
                                line = dict(color='black', width=2),
                                marker=dict(size=16,
                                            color=list(waterfall[waterfall["Type"] == "Negative"]["Value"]),
                                            cmax=1.,#max(list(waterfall["Value"])),
                                            cmin=0.,#min(list(waterfall["Value"])),
                                            colorscale=["#E3E3E3", "#356E97"],
                                            symbol = 6,
                                            line=dict(width=1,color='Black')
                                            )))

    figWF.add_traces(go.Scatter(x=[waterfall["Feature"].iloc[0],waterfall["Feature"].iloc[-1]], y=[waterfall["Value"].iloc[0], waterfall["Value"].iloc[0]],
                                mode='lines',
                                name = "Risk Baseline", 
                                line = dict(color="#222222", width=2, dash = "dot"),))

    figWF.add_traces(go.Scatter(x=[waterfall["Feature"].iloc[-1]], y=[waterfall["Value"].iloc[-1]+0.02],
                                mode='text',
                                name = "Final Risk", 
                                text = ["Final Risk"],
                                textposition="top center",))

    figWF.update_layout(title = "<b>Cumulative Risk:</b>",
                        template="plotly_white", 
                        margin=dict(r=0),
                        yaxis_range=[0,1],
                        legend=dict(
                            orientation="h",
                            yanchor="top",
                            y=-0.4,
                            xanchor="center",
                            x=0.5))
    return figWF



#+======================================================================================================+
#|                                PLOTTING FUNCTIONS TIME EVOLUTION                                     |
#+======================================================================================================+
#+------------------------------------------------------------------------------------------------------+
#|                                       Delta Risks Evolution                                          |
#+------------------------------------------------------------------------------------------------------+
def deltaRiskEvolutionGraph(temporalContrib):
    n_rows = floor(np.sqrt(len(list(temporalContrib.columns))))
    n_columns = ceil(len(list(temporalContrib.columns))/n_rows)

    fig = make_subplots(rows=n_rows, cols=n_columns, subplot_titles = tuple(temporalContrib.columns))

    features = list(temporalContrib.columns)
    feature_used = 0
    entries = list(range(len(temporalContrib)))
    for i in range(n_rows):
        for j in range(n_columns):
            if feature_used < len(features):
                fig.add_trace(
                    go.Scatter(x=entries, y=temporalContrib[features[feature_used]]),
                    row=i+1, col=j+1
                )
                feature_used +=1

    fig.update_layout(showlegend=False,
                      title_text = "<b>Features Delta Risk Evolution in Time</b>",
                      colorway = px.colors.sequential.ice,
                      template="plotly_white")
    return(fig)

#+------------------------------------------------------------------------------------------------------+
#|                                        Total Risk Evolution                                          |
#+------------------------------------------------------------------------------------------------------+
def plotRiskEvolution(riskEvolution):
    figRiskEvolution = px.line(riskEvolution, x="Entry", y="RiskEvolution",
                        template="plotly_white",
                        title = "<b>Temporal Evolution</b><br>➊ Color: <i>Total Risk Evolution In Time</i>",
                        color_discrete_sequence= ['#111111'])
    figRiskEvolution.add_traces(go.Scatter(x=riskEvolution["Entry"],
                                y=riskEvolution["RiskEvolution"], 
                                mode='markers',
                                name = "RiskEvolution",
                                marker=dict(size=20,
                                            color=list(riskEvolution["RiskEvolution"]),
                                            cmax=1.0,
                                            cmin=0.0,
                                            colorscale=["#356E97", "#E3E3E3", "#851E2F"],
                                            colorbar=dict(thickness=30)
                                            )
                               )
                    )
    figRiskEvolution.update_layout(autosize = True,
                        showlegend=False,
                        height=700,
                        yaxis_range=[0,1],
                        legend=dict(
                            orientation="h",
                            yanchor="top",
                            y=-0.1,
                            xanchor="center",
                            x=0.5))
    return(figRiskEvolution)

#+------------------------------------------------------------------------------------------------------+
#|                                       3D Time Evolution Plot                                         |
#+------------------------------------------------------------------------------------------------------+
def temporalContrib3D(temporalContrib2):
    fig3D = px.line_3d(temporalContrib2, x="Entry", y="Feature", z="Value",  
                    template="plotly_white",
                    title = "<b>Temporal Evolution</b><br>➊ Color: <i>Features Delta Risk Contribution in Time</i>",
                    color = "Entry", 
                    color_discrete_sequence= ['#999999','#777777','#555555','#333333','#111111'])
    fig3D.add_traces(go.Scatter3d(x=temporalContrib2["Entry"], y=temporalContrib2["Feature"], z=temporalContrib2["Value"], 
                                mode='markers',
                                name = "Delta Risk",
                                marker=dict(size=5,
                                            color=list(temporalContrib2["Value"]),
                                            cmax=max(list(temporalContrib2["Value"])),
                                            cmin=min(list(temporalContrib2["Value"])),
                                            colorscale=["#356E97", "#E3E3E3", "#851E2F"],
                                            )
    ))
    fig3D.update_layout(autosize= True,height=700)
    return fig3D










def graphPathPDTA(PDTA_Features):
    # Define the color code for the link and the blocks
    colorCode, HasBlesLabel, missingFeatures = bleeding_pdta(PDTA_Features)
    
    # Define the X positions of the blocks
    x0 = 0.01
    d05 = 0.05
    d10 = 0.10
    d15 = 0.15
    d20 = 0.20
    d25 = 0.25
    d30 = 0.30
    d35 = 0.35
    d40 = 0.40
    d45 = 0.45
    d50 = 0.50
    d90 = 0.90


    fig = go.Figure(go.Sankey(
        arrangement = "snap",
        node = {
            "label": ["Patient",  "Missing Features", "No Prior PCI ", "PriorPCI", "No Stent DES", "Stent DES",  "No DAPT", "AAS+Clopi", "AAS+Prasu", "AAS+Tica", "HAS BLED", "Low Bleeding Risk", "High Bleedind Risk",  "Go on with DAPT > 6 months", "DAPT Suspension", "Not enough data"],
            "customdata": ["Patient",  missingFeatures, "Prior PCI ", "Prior PCI", "Stent DES", " Stent DES",  "DAPT", "AAS+Clopi", "AAS+Prasu", "AAS+Tica", "HAS BLED ", "Low Bleeding Risk", "High Bleedind Risk",  "Go on with DAPT > 6 months", "Tica or Clopi or Prasu Suspension, after 3 months go on with ASA", "Not enough data"],
            "color": colorCode[1],
            "hovertemplate": 'PDTA Node: %{customdata}<extra></extra>',
            "x": [x0, x0+d05, x0+d05, x0+d10, x0+d15, x0+d20, x0+d25, x0+d30, x0+d30, x0+d30, x0+d40, x0+d50, x0+d50, x0+d90, x0+d90],
            "y": [0.50, 0.15, 0.80, 0.50, 0.90, 0.50,    1, 0.15, 0.45, 0.75,    0.45, 0.6, 0.3, 0.8, 0.1],
            'pad':10},  # 10 Pixels
        link = {
            "source": [0, 0, 0, 3, 3, 5, 5, 5, 5, 7, 8, 9, 10, 10, 11, 12],
            "target": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 10, 10, 11, 12, 13, 14],
            "value": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ,1, 1, 1, 1],
            "color": colorCode[0],
            "customdata":["has the following missing features for HAS BLED:","has NO","has","is NOT in combination with a","is in combination with a","is NOT in combination with","is in combination with","is in combination with","is in combination with","has a score","has a score","has a score", "is under threshold ("+HasBlesLabel+") with", "is over threshold ("+HasBlesLabel+") with", "treatment is:", "treatment is:"],
            "hovertemplate": '%{source.customdata} %{customdata}<br />'+'%{target.customdata} <extra></extra>',}))

    fig.update_layout(title = "<b>PDTA Path:</b>",
                        height=400,
                        template="plotly_white", 
                        margin=dict(r=0))

    return(fig)





def graphPathPDTAModel(PDTA_Features, ModelBarcIsotonicScore):
    # Define the color code for the link and the blocks
    colorCode, HasBlesLabel = bleeding_pdta_Model(PDTA_Features, ModelBarcIsotonicScore)
    
    # Define the X positions of the blocks
    x0 = 0.01
    d05 = 0.05
    d10 = 0.10
    d15 = 0.15
    d20 = 0.20
    d25 = 0.25
    d30 = 0.30
    d35 = 0.35
    d40 = 0.40
    d45 = 0.45
    d50 = 0.50
    d90 = 0.90


    fig = go.Figure(go.Sankey(
        arrangement = "snap",
        node = {
            "label": ["Patient",  "Missing Features", "No Prior PCI ", "PriorPCI", "No Stent DES", "Stent DES",  "No DAPT", "AAS+Clopi", "AAS+Prasu", "AAS+Tica", "NEAR Prediction", "Low Bleeding Risk", "High Bleedind Risk",  "Go on with DAPT > 6 months", "DAPT Suspension", "Not enough data"],
            "customdata": ["Patient",  "----", "Prior PCI ", "Prior PCI", "Stent DES", " Stent DES",  "DAPT", "AAS+Clopi", "AAS+Prasu", "AAS+Tica", "NEAR Prediction ", "Low Bleeding Risk", "High Bleedind Risk",  "Go on with DAPT > 6 months", "Tica or Clopi or Prasu Suspension, after 3 months go on with ASA", "Not enough data"],
            "color": colorCode[1],
            "hovertemplate": 'PDTA Node: %{customdata}<extra></extra>',
            "x": [x0, x0+d05, x0+d05, x0+d10, x0+d15, x0+d20, x0+d25, x0+d30, x0+d30, x0+d30, x0+d40, x0+d50, x0+d50, x0+d90, x0+d90],
            "y": [0.50, 0.15, 0.80, 0.50, 0.90, 0.50,    1.0, 0.15, 0.45, 0.75,    0.45, 0.6, 0.3, 0.8, 0.1],
            'pad':10},  # 10 Pixels
        link = {
            "source": [0, 0, 0, 3, 3, 5, 5, 5, 5, 7, 8, 9, 10, 10, 11, 12],
            "target": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 10, 10, 11, 12, 13, 14],
            "value": [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ,1, 1, 1, 1],
            "color": colorCode[0],
            "customdata":["----","has NO","has","is NOT in combination with a","is in combination with a","is NOT in combination with","is in combination with","is in combination with","is in combination with","has a score","has a score","has a score", "is under threshold ("+HasBlesLabel+") with", "is over threshold ("+HasBlesLabel+") with", "treatment is:", "treatment is:"],
            "hovertemplate": '%{source.customdata} %{customdata}<br />'+'%{target.customdata} <extra></extra>',}))

    fig.update_layout(title = "<b>PDTA Path predicted by NEAR Barc Model:</b>",
                        height=400,
                        template="plotly_white", 
                        margin=dict(r=0))

    return(fig)

PDTA_Features = {'Age': None,
                      'eGFR (MDRD)': None,
                      'Female': 1,
                      "PriorPCI": 1,
                      "Stent_DES": 1,
                      "AAS": 1,
                      "clopidogrel": 1,
                      "Prasu": 0,  
                      "Tica": 0,  
                      "ethnicity": 0,
                      "hypertension": None, 
                      "PriorStroke": None,
                      "PriorBleeding": None}
#graphPathPDTA(PDTA_Features)

#graphPathPDTAModel(PDTA_Features, 5)

'''    risk = iso_reg.predict([0.55])
    risk = round(risk[0]*100,4)
    #df = pd.DataFrame.from_dict({"Prediction Value": [risk, 100-risk], "Class": ["At Risk", "Not at Risk"]})
    df = pd.DataFrame.from_dict({"Prediction Value": [risk], "Class": ["Predicted Risk"]})
    piePalette = ["#851E2F",'#356E77']
    

    fig = go.Figure()
    
    fig.add_traces(go.Scatter(x=df["Class"], y=df["Prediction Value"],
                                mode='markers',
                                name='Predicted Risk',
                                line = dict(color='black', width=2),
                                marker=dict(size=20,
                                            color=list(df["Prediction Value"]),
                                            cmax=19.,#max(list(waterfall["Value"])),
                                            cmin=0.,#min(list(waterfall["Value"])),
                                            colorscale=['#356E77', "#851E2F"],
                                            symbol = 204,
                                            line=dict(width=1,color='Black'),
                                            colorbar=dict(
                                                tick0=0,
                                                #dtick=1
                                            ),
                                            )))
    
    fig.add_traces(go.Scatter(x=[df["Class"].iloc[-1]], y=[df["Prediction Value"].iloc[-1]+1],
                                mode='text',
                                name = "Final Risk", 
                                text = [str(str(round(risk,2))+"%")],
                                textposition="top center",
                                textfont=dict(
                                    size=16,
                                    color="Black"))
                    )
    


    fig.update_layout(title = "<b>Predicted Risk:</b>",
                        template="plotly_white", 
                        margin=dict(r=0),
                        yaxis_range=[0,20],
                        legend=dict(
                            orientation="h",
                            yanchor="top",
                            y=-0.4,
                            xanchor="center",
                            x=0.5))
    fig.show()
'''

"""## PDTA FUNCTIONS"""

def treatment(aas, clopidogrel, prasu, tica):
    if(aas==1 and clopidogrel==1):
        return 'clopi'
    elif(aas==1 and prasu==1):
        return 'prasu'
    elif(aas==1 and tica==1):
        return 'tica'
    else:
        return 'no_pharma'

def hasBled(hypertension, creatinine, prior_stroke, prior_bleeding, age):  # maximum has-bled score with these inputs is 5, but it should be 9
    score = 0

    if(creatinine>=2.2):
        score = score + 1
    if(age>65):
        score = score + 1
    if(hypertension==1):
        score = score + 1
    if(prior_stroke==1):
        score = score + 1
    if(prior_bleeding==1):
        score = score + 1

    return score

## PDTA WITH HAS BLED
def bleeding_pdta(patient):
    # Define the possible Colors
    # Link
    gray = "rgba(0,0,0, 0.05)"
    blue = "rgba(0,0,255, 0.15)"
    green = "rgba(0,255,0, 0.3)"
    red = "rgba(255,0,0, 0.15)"
    # Blocks
    gray2 = "rgba(0,0,0, 0.05)"
    blue2 = "rgba(0,0,255, 0.5)"
    green2 = "rgba(0,255,0, 0.3)"
    red2 = "rgba(255,0,0, 0.3)"
    
    no_data = [[blue, gray, gray, gray, gray, gray, gray, gray , gray, gray ,gray, gray, gray, gray ,gray, gray], [blue2, blue2, gray2, gray2, gray2, gray2, gray2, gray2 , gray2, gray2 ,gray2, gray2, gray2, gray2 ,gray2]]
    no_pci = [[gray, blue, gray, gray, gray, gray, gray, gray , gray, gray ,gray, gray, gray, gray ,gray, gray], [blue2, gray2, blue2, gray2, gray2, gray2, gray2, gray2, gray2, gray2, gray2, gray2, gray2, gray2, gray2]] 
    no_stent = [[gray, gray, blue, blue, gray, gray, gray, gray , gray, gray ,gray, gray, gray, gray ,gray, gray], [blue2, gray2, gray2, blue2, blue2, gray2, gray2, gray2, gray2, gray2, gray2, gray2, gray2, gray2, gray2]] 
    no_pharma = [[gray, gray, blue, gray, blue, blue, gray, gray , gray, gray ,gray, gray, gray, gray ,gray, gray], [blue2, gray2, gray2, blue2, gray2, blue2, blue2, gray2, gray2, gray2, gray2, gray2, gray2, gray2, gray2]] 

    clopi_highRisk = [[gray, gray, red, gray, red, gray, red, gray , gray, red ,gray, gray, gray, red ,gray, red], [red2, gray2, gray2, red2, gray2, red2, gray2, red2, gray2, gray2, red2, gray2, red2, gray2, red2]] 
    clopi_lowRisk = [[gray, gray, green, gray, green, gray, green, gray , gray, green ,gray, gray, green, gray ,green, gray], [green2, gray2, gray2, green2, gray2, green2, gray2, green2, gray2, gray2, green2, green2, gray2, green2, gray2]] 

    prasu_highRisk = [[gray, gray, red, gray, red, gray, gray, red , gray, gray ,red, gray, gray, red ,gray, red], [red2, gray2, gray2, red2, gray2, red2, gray2, gray2, red2, gray2, red2, gray2, red2, gray2, red2]] 
    prasu_lowRisk = [[gray, gray, green, gray, green, gray, gray, green, gray, gray, green, gray, green, gray ,green, gray], [green2, gray2, gray2, green2, gray2, green2, gray2, gray2, green2, gray2, green2, green2, gray2, green2, gray2]] 

    tica_highRisk = [[gray, gray, red, gray, red, gray, gray, gray , red, gray ,gray, red, gray, red ,gray, red], [red2, gray2, gray2, red2, gray2, red2, gray2, gray2, gray2, red2, red2, gray2, red2, gray2, red2]] 
    tica_lowRisk = [[gray, gray, green, gray, green, gray, gray, gray , green, gray ,gray, green, green, gray ,green, gray], [green2, gray2, gray2, green2, gray2, green2, gray2, gray2, gray2, green2, green2, green2, gray2, green2, gray2]] 

    error = [[gray, gray, gray, gray, gray, gray, gray, gray , gray, gray ,gray, gray, gray, gray ,gray, gray], [gray2, gray2, gray2, gray2, gray2, gray2, gray2, gray2, gray2, gray2, gray2, gray2, gray2, gray2, gray2]] 

    '''
    Returns:
    # 'no_data' when not enough data are available to compute has-bled score
    # 'no_pci' if the patient has PCI=0
    # 'no_stent' if the patient does not have a stent
    # 'no_pharma' if the patient is not treated
    # 'clopi_highRisk' if the patient is treated with Clopidogrel and has-bled score is over the threshold
    # 'clopi_lowRisk' if the patient is treated with Clopidogrel and has-bled score is below the threshold
    # 'prasu_highRisk' if the patient is treated with Prasu and has-bled score is over the threshold
    # 'prasu_lowRisk' if the patient is treated with Prasu and has-bled score is below the threshold
    # 'tica_highRisk' if the patient is treated with Tica and has-bled score is over the threshold
    # 'tica_lowRisk' if the patient is treated with Tica and has-bled score is below the threshold
    # 'error' in case of unexpected error
    '''

    # Patient's features
    priorPCI = patient['PriorPCI']
    stent_des = patient['Stent_DES']
    aas = patient['AAS']
    clopidogrel = patient['clopidogrel']
    prasu = patient['Prasu']
    tica = patient['Tica']
    hypertension = patient['hypertension']
    #creatinine = patient['creatinine']
    prior_stroke = patient['PriorStroke']
    prior_bleeding = patient['PriorBleeding']
    age = patient['Age']
    egfr = patient['eGFR (MDRD)']
    female = patient['Female']
    ethnicity = patient['ethnicity']

    # Compute the creatinine value
    if egfr != None:
        if female == 0: 
            if ethnicity == 0:
                creatinine = (egfr/(175*(age**(-0.203))))**(-1/1.154)
            else:
                creatinine = (egfr/(175*(age**(-0.203))*1.212))**(-1/1.154)
        else:
            if ethnicity == 0:
                creatinine = (egfr/(175*(age**(-0.203))*0.742))**(-1/1.154)
            else:
                creatinine = (egfr/(175*(age**(-0.203))*1.212*0.742))**(-1/1.154)
         # ROund up 
        if creatinine*10 - int(creatinine*10)>0: 
            creatinine = ((int(creatinine*10)+1)/10) 
    else:
        creatinine = None


    # PDTA conditions

    ### PCI
    if(priorPCI != 1):
        return no_pci, "", "-"

    ### DES
    if(stent_des != 1):
        return no_stent, "", "-"

    ### PHARMA TREATMENT
    treatment_cond = treatment(aas=aas, clopidogrel=clopidogrel, prasu=prasu, tica=tica)
    if(treatment_cond=='no_pharma'):
        return no_pharma, "", "-"


    ### has-bled
    max_theory_score = 9
    threshold = 3
    min_features = 3
    hasBled_features_dict = {"hypertension": hypertension, "creatinine (eGFR MDRD)": creatinine, "prior_stroke": prior_stroke, "prior_bleeding": prior_bleeding, "age": age}
    
    missingFeatures = ''
    for x in hasBled_features_dict.keys():
        if hasBled_features_dict[x] == None: 
            missingFeatures = missingFeatures + x + ', '

    num_features = len(list(hasBled_features_dict.values())) - sum(x == None for x in list(hasBled_features_dict.values()))  # number of not null features for the score calculation
    if(num_features < min_features):
        return no_data, "", missingFeatures

    has_bled = hasBled(hypertension=hypertension, creatinine=creatinine, prior_stroke=prior_stroke, prior_bleeding=prior_bleeding, age=age)
    has_bled_threshold = (num_features/max_theory_score)*threshold
    if(has_bled >= has_bled_threshold):
        high_risk = 1
        hasBledLabel = str(has_bled)+">"+str(round(has_bled_threshold,1))
    else:
        high_risk = 0
        hasBledLabel = str(has_bled)+"<"+str(round(has_bled_threshold,1))

    
    if(treatment_cond=='clopi' and high_risk==1):
        return clopi_highRisk, hasBledLabel, missingFeatures
    elif(treatment_cond=='clopi' and high_risk==0):
        return clopi_lowRisk, hasBledLabel, missingFeatures
    elif(treatment_cond=='prasu' and high_risk==1):
        return prasu_highRisk, hasBledLabel, missingFeatures
    elif(treatment_cond=='prasu' and high_risk==0):
        return prasu_lowRisk, hasBledLabel, missingFeatures
    elif(treatment_cond=='tica' and high_risk==1):
        return tica_highRisk, hasBledLabel, missingFeatures
    elif(treatment_cond=='tica' and high_risk==0):
        return tica_lowRisk, hasBledLabel, missingFeatures
    else:
        return error, "", '-' 
    
    
    
    
    

def bleeding_pdta_Model(patient, ModelBarcIsotonicScore):
    # Define the possible Colors
    # Link
    gray = "rgba(0,0,0, 0.05)"
    blue = "rgba(0,0,255, 0.15)"
    green = "rgba(0,255,0, 0.3)"
    red = "rgba(255,0,0, 0.15)"
    # Blocks
    gray2 = "rgba(0,0,0, 0.05)"
    blue2 = "rgba(0,0,255, 0.5)"
    green2 = "rgba(0,255,0, 0.3)"
    red2 = "rgba(255,0,0, 0.3)"
    
    no_data = [[blue, gray, gray, gray, gray, gray, gray, gray , gray, gray ,gray, gray, gray, gray ,gray, gray], [blue2, blue2, gray2, gray2, gray2, gray2, gray2, gray2 , gray2, gray2 ,gray2, gray2, gray2, gray2 ,gray2]]
    no_pci = [[gray, blue, gray, gray, gray, gray, gray, gray , gray, gray ,gray, gray, gray, gray ,gray, gray], [blue2, gray2, blue2, gray2, gray2, gray2, gray2, gray2, gray2, gray2, gray2, gray2, gray2, gray2, gray2]] 
    no_stent = [[gray, gray, blue, blue, gray, gray, gray, gray , gray, gray ,gray, gray, gray, gray ,gray, gray], [blue2, gray2, gray2, blue2, blue2, gray2, gray2, gray2, gray2, gray2, gray2, gray2, gray2, gray2, gray2]] 
    no_pharma = [[gray, gray, blue, gray, blue, blue, gray, gray , gray, gray ,gray, gray, gray, gray ,gray, gray], [blue2, gray2, gray2, blue2, gray2, blue2, blue2, gray2, gray2, gray2, gray2, gray2, gray2, gray2, gray2]] 

    clopi_highRisk = [[gray, gray, red, gray, red, gray, red, gray , gray, red ,gray, gray, gray, red ,gray, red], [red2, gray2, gray2, red2, gray2, red2, gray2, red2, gray2, gray2, red2, gray2, red2, gray2, red2]] 
    clopi_lowRisk = [[gray, gray, green, gray, green, gray, green, gray , gray, green ,gray, gray, green, gray ,green, gray], [green2, gray2, gray2, green2, gray2, green2, gray2, green2, gray2, gray2, green2, green2, gray2, green2, gray2]] 

    prasu_highRisk = [[gray, gray, red, gray, red, gray, gray, red , gray, gray ,red, gray, gray, red ,gray, red], [red2, gray2, gray2, red2, gray2, red2, gray2, gray2, red2, gray2, red2, gray2, red2, gray2, red2]] 
    prasu_lowRisk = [[gray, gray, green, gray, green, gray, gray, green, gray, gray, green, gray, green, gray ,green, gray], [green2, gray2, gray2, green2, gray2, green2, gray2, gray2, green2, gray2, green2, green2, gray2, green2, gray2]] 

    tica_highRisk = [[gray, gray, red, gray, red, gray, gray, gray , red, gray ,gray, red, gray, red ,gray, red], [red2, gray2, gray2, red2, gray2, red2, gray2, gray2, gray2, red2, red2, gray2, red2, gray2, red2]] 
    tica_lowRisk = [[gray, gray, green, gray, green, gray, gray, gray , green, gray ,gray, green, green, gray ,green, gray], [green2, gray2, gray2, green2, gray2, green2, gray2, gray2, gray2, green2, green2, green2, gray2, green2, gray2]] 

    error = [[gray, gray, gray, gray, gray, gray, gray, gray , gray, gray ,gray, gray, gray, gray ,gray, gray], [gray2, gray2, gray2, gray2, gray2, gray2, gray2, gray2, gray2, gray2, gray2, gray2, gray2, gray2, gray2]] 

    '''
    Returns:
    # 'no_data' when not enough data are available to compute has-bled score
    # 'no_pci' if the patient has PCI=0
    # 'no_stent' if the patient does not have a stent
    # 'no_pharma' if the patient is not treated
    # 'clopi_highRisk' if the patient is treated with Clopidogrel and has-bled score is over the threshold
    # 'clopi_lowRisk' if the patient is treated with Clopidogrel and has-bled score is below the threshold
    # 'prasu_highRisk' if the patient is treated with Prasu and has-bled score is over the threshold
    # 'prasu_lowRisk' if the patient is treated with Prasu and has-bled score is below the threshold
    # 'tica_highRisk' if the patient is treated with Tica and has-bled score is over the threshold
    # 'tica_lowRisk' if the patient is treated with Tica and has-bled score is below the threshold
    # 'error' in case of unexpected error
    '''
    # Patient's features
    priorPCI = patient['PriorPCI']
    stent_des = patient['Stent_DES']
    aas = patient['AAS']
    clopidogrel = patient['clopidogrel']
    prasu = patient['Prasu']
    tica = patient['Tica']

    
    # PDTA conditions

    ### PCI
    if(priorPCI != 1):
        return no_pci, ""

    ### DES
    if(stent_des != 1):
        return no_stent, ""

    ### PHARMA TREATMENT
    treatment_cond = treatment(aas=aas, clopidogrel=clopidogrel, prasu=prasu, tica=tica)
    if(treatment_cond=='no_pharma'):
        return no_pharma, ""


    ### has-bled
    isotonic_threshold = pdtaIsotinicThreshold

    if(ModelBarcIsotonicScore >= isotonic_threshold):
        high_risk = 1
        isotonicLabel = str(ModelBarcIsotonicScore)+">="+str(round(isotonic_threshold,1))
    else:
        high_risk = 0
        isotonicLabel = str(ModelBarcIsotonicScore)+"<"+str(round(isotonic_threshold,1))

    
    if(treatment_cond=='clopi' and high_risk==1):
        return clopi_highRisk, isotonicLabel
    elif(treatment_cond=='clopi' and high_risk==0):
        return clopi_lowRisk, isotonicLabel
    elif(treatment_cond=='prasu' and high_risk==1):
        return prasu_highRisk, isotonicLabel
    elif(treatment_cond=='prasu' and high_risk==0):
        return prasu_lowRisk, isotonicLabel
    elif(treatment_cond=='tica' and high_risk==1):
        return tica_highRisk, isotonicLabel
    elif(treatment_cond=='tica' and high_risk==0):
        return tica_lowRisk, isotonicLabel
    else:
        return error, ""

"""## APP EXECUTION"""

#+======================================================================================================+
#|                                GLOBAL VARIABLES AND COSTANTS                                         |
#+======================================================================================================+
age = 50
LVEF = 50
eGFR = 9
sex = 0
ethnicity = "White"

Hb = 14
HyperT = None
cRevasc = None

Hyperlip = None
PAD = None
PrAMI = None
PrCABG = None
PrStroke = None
PrBleed = None
Malignancy = None
STEMI = None
NSTEMI = None
DMellitus = None

AAS = None
Prasu = None
Tica = None
clopidogrel = None
ACEiARB = None
Statin = None
PPI = None
OAC_total = None
Multivessel = None
PriorPCI = None
Stent_DES = None
BB = None

# List of the global features importance computed by SHAP
"""features_importance = {'Hb':0.003139369,
                       "Creatinine":0.001528,
                       "eGFR":0.00138768,
                       "Age":0.001148472,
                       'LVEF':0.000843445,
                       "Complete Revasc.":0.00026928,
                       "Diabetes":0.00016991,
                       "Branch Block":0.000112843,
                       "Hypertension":0.00017056,
                       "Sex":0.00011984}"""


aboutNear = [html.P("What is NEAR?", className = "typography-question"),
            html.P("NEAR is a Data Driven predictive model derived from the training of Artificial Neural Networks (ANN)."),
            html.P("The aim of NEAR model is to reshape the knowledge of a Neural Network in an explainable model which can be interpreted and evaluated from doctors and clinician."),
            html.P("Unlike classic ANN models, NEAR does not require all the inout parameters used for training. This flexibility has the price of a loss of reliability in the calculated score proportional to the number of missing values."),
            html.P("Thanks to its interpretability combined with the power of the data driven approach and graceful degradation, this model aims to pave the way for the Digital Twin in healthcare.")
            ]

aboutUs = [html.P("The Project", className = "typography-question"),
           html.P("NEAR fits in the Alta Scuola Politecnica XVII cycle multidisciplinary project called YouForAll: Your digital twin for aLLowing a healthy society (Y4A)."),
           dcc.Markdown('''Y4A is born from a collaboration of [ASP (Alta Scuola Politecnica)](https://www.asp-poli.it/) and [Dedalus Italia s.p.a](https://www.dedalus.com/global/en/) (the leading provider of health and diagnostic software in Europe and one of the largest in the world) with two main aims:'''),
           html.P("Model a digital twin paradigm for each citizen, profiling the data, through AI methodologies, based on specific health targets", 
                  className="markdown-style"),
           html.P("Define cloud-based solutions, for allowing the seamless and automatic integration among the personal digital twin management and the clinical information systems, so that the institutional health systems can guarantee citizens with targeted prevention, early enrolment on and the activation of personalized care processes.",
                         className="markdown-style"),
           html.P("The Group:", className = "typography-question"),
           html.P("Four students compose the team:"),
           dcc.Markdown('''**Kassem Karim: ** the **Team Leader** and a *biomedical engineer* from the Politecnico di Milano''', className="markdown-style"),
           dcc.Markdown('''**Cavallo Andrea: ** an *informatics engineer* from the Politecnico di Torino''', className="markdown-style"),
           dcc.Markdown('''**Fassino Davide: ** a *mathematical engineer* from the Politecnico di Torino''', className="markdown-style"),
           dcc.Markdown('''**Vergani Andrea Mario: ** an *informatics engineer* from the Politecnico di Milano''', className="markdown-style"),
           html.P("The students worked under the supervision of the academic tutors:"),
           dcc.Markdown('''**Prof. Della Valle Emanuele: ** informatics professor at the Politecnico di Milano''', className="markdown-style"),
           dcc.Markdown('''**Prof. Deriu Marco: ** biomedical professor at the Politecnico di Torino''', className="markdown-style"),
           html.P("with the collaboration of:"),
           dcc.Markdown('''**Dedalus Italia s.p.a  Architecture Team**''', className="markdown-style"),
           html.P("and a special thank to:"),
           dcc.Markdown('''**Sperti Michela:** PhD student at Politecnico di Torino''', className="markdown-style"),
           dcc.Markdown('''**Banali Riccardo:** member of Dedalus Italia s.p.a  Architecture Team''', className="markdown-style"),
          ]

aboutTimeAnalysis = [html.P("Multiple Entry Analysis:", className = "typography-question"),
            html.P("By processing multiple sets of input parameterescollected over time, the model is able to highlight the evolution of risk in the patient, in which aspects the patient has improved and which ones put him at risk"),
            html.P("Furthermore, thanks to the understanding of the importance of each feature in the predictive model, NEAR is able to highlight shortcomings in specialized axaminations that would improve the reliability of the prediction and the understanding of the clinical picture."),

            ]

aboutPDTA = [html.P("Bleeding Integrated Care Pathways :", className = "typography-question"),
             html.P("Integrated care pathways (or PDTA - Percorsi Diagnostico Terapeutici Assistenziali) are structured care plans which detail essential steps in the care of patients with a specific clinical problem like the bleeding event in Acute Coronary Syndrome (ACS) patients"),
             html.P("In the following the same PDTA is presented with 2 variations: the first one use the HAS BLED score to discriminate the bleeding risk while the second one use the prediction of our model NEAR-Bleeding"), ]



# CODE FOT IMAGE GENERATION
'''
from skimage import io
img = io.imread(projectRoot + 'images/NoDataFound.PNG')
with open('C:/Users/kkass/Desktop/Polimi/Laurea/ASP/ProjectApp/images/NoDataFound.pickle', 'wb') as handle:
    pickle.dump(img, handle, protocol=pickle.HIGHEST_PROTOCOL)
'''
# OPEN THE IMAGE
with open('C:/Users/kkass/Desktop/Polimi/Laurea/ASP/ProjectApp/images/NoDataFound.pickle', 'rb') as handle:
    img = pickle.load(handle)

app = JupyterDash(__name__,external_stylesheets = external_stylesheets) 
server = app.server
app.title = "NEAR by Y4A"

#+======================================================================================================+
#|                                       ABOUT US AND ABOUT NEAR                                        |
#+======================================================================================================+
aboutTabs = html.Div([dcc.Tabs([
                                    dcc.Tab(label='About the project', children=aboutNear),
                                    dcc.Tab(label='About the team', children=aboutUs)
                                        ]),  
                                ],
                                className = "lowercontrol-tabs",
                                style={
                                    "verticalAlign": "top",
                                    "text-align": "justify",
                                    "width": "92%",
                                    "display": "inline-block",
                                })

#+======================================================================================================+
#|                                     TITLE BOX AND LOGOS                                              |
#+======================================================================================================+
titleBox = html.Div(
    children=[ 
        html.Div(children = [
        html.A(
            id='asp-logo', children=[
                html.Img(src=aspLogo, className = "aspLogo")
            ],
                        href="https://www.asp-poli.it/"
                    ),],
    style={"display": "inline-block",
           "verticalAlign": "middle",
           "width": "12%",}),
        
        html.Div(children = [
        html.P("NEAR: ", className = "typography-title", style={"display": "inline"}),
        html.P("Neural imputed Explainable and Adaptive Risk score", className = "typography-subtitle", style={"display": "inline"})
            ],
    style={"display": "inline-block",
           "verticalAlign": "top",
           "width": "76%",}),
        
        
        html.Div(children = [
        html.A(
            id='y4a-logo', children=[
                html.Img(src=y4aLogo, className = "y4aLogo")
            ],
                        href="https://www.asp-poli.it/"
                    ),],
    style={"display": "inline-block",
           "verticalAlign": "middle",
           "width": "12%",}),
            ],
    className = "title-box",
    style={"display": "inline",}
)

#+======================================================================================================+
#|                                          INPUT FEATURES                                              |
#+======================================================================================================+
#+--------------------------------------------------------------------------+
#|                    TAB: Input Predictors Tab                             |
#+--------------------------------------------------------------------------+
predictorsInput = html.Div([
                                          html.H5("Clinical variables"),
                                          dcc.Markdown('''**Sex:**'''),
                                          dcc.Dropdown(id='sex',
                                                      searchable=False,
                                                      options=[
                                                                {'label': 'Male', 'value': 'Male'},
                                                                {'label': 'Female', 'value': 'Female'},
                                                            ],
                                                      value = 'Male'),
                                          
                                          dcc.Markdown('''**Ethnicity:**'''),
                                          dcc.Dropdown(id='ethnicity',
                                                      searchable=False,
                                                      options=[
                                                                {'label': 'White', 'value': 'White'},
                                                                {'label': 'Black', 'value': 'Black'}
                                                            ],
                                                      value = 'White'),
    
                                          dcc.Markdown('''**Age:**'''),
                                          dcc.Slider(id='AgeSlider', min=10, max=100, value=50, tooltip={"placement": "bottom", "always_visible": True}),
                                          dcc.Markdown('''**LVEF:**'''),
                                          dcc.Checklist(options = [{'label': "I don't know", 'value': 'Null'}], className = "checklist-style", id = "LVEFNull"),
                                          dcc.Slider(id='LVEFSlider', min=20, max=80, value=50, tooltip={"placement": "bottom", "always_visible": True}),
                                          dcc.Markdown('''**eGFR:**'''),
                                          dcc.Checklist(options = [{'label': "I don't know", 'value': 'Null'}], className = "checklist-style", id = "EGFRNull"),
                                          dcc.Slider(id='EGFRSlider', min=2, max=200, value=80, tooltip={"placement": "bottom", "always_visible": True}),
                                          dcc.Markdown('''**Hemoglobin (g/dL):**'''),
                                          dcc.Checklist(options = [{'label': "I don't know", 'value': 'Null'}], className = "checklist-style", id = "HbNull"),
                                          dcc.Slider(id='HbSlider', min=0, max=20, step=0.01, value=12, tooltip={"placement": "bottom", "always_visible": True}),
                                
    
                                          dcc.Markdown('''**Hypertension:**'''),
                                          dcc.Dropdown(id='hypertension',
                                                      searchable=False,
                                                      options=[
                                                                {'label': 'Yes', 'value': 'Yes'},
                                                                {'label': 'No', 'value': 'No'},
                                                                {'label': "I don't know", 'value': 'Null'},
                                                            ],
                                                      value = 'Null'),
                                          
                                          dcc.Markdown('''**Hyperlipidemia:**'''),
                                          dcc.Dropdown(id='Hyperlipidemia',
                                                      searchable=False,
                                                      options=[
                                                                {'label': 'Yes', 'value': 'Yes'},
                                                                {'label': 'No', 'value': 'No'},
                                                                {'label': "I don't know", 'value': 'Null'},
                                                            ],
                                                      value = 'Null'),
                                        
                                          dcc.Markdown('''**Peripheral Artery Disease:**'''),
                                          dcc.Dropdown(id='PAD',
                                                      searchable=False,
                                                      options=[
                                                                {'label': 'Yes', 'value': 'Yes'},
                                                                {'label': 'No', 'value': 'No'},
                                                                {'label': "I don't know", 'value': 'Null'},
                                                            ],
                                                      value = 'Null'),
                                        
                                          dcc.Markdown('''**Prior AMI:**'''),
                                          dcc.Dropdown(id='PriorAMI',
                                                      searchable=False,
                                                      options=[
                                                                {'label': 'Yes', 'value': 'Yes'},
                                                                {'label': 'No', 'value': 'No'},
                                                                {'label': "I don't know", 'value': 'Null'},
                                                            ],
                                                      value = 'Null'),
                                        
                                          dcc.Markdown('''**Prior CABG:**'''),
                                          dcc.Dropdown(id='PriorCABG',
                                                      searchable=False,
                                                      options=[
                                                                {'label': 'Yes', 'value': 'Yes'},
                                                                {'label': 'No', 'value': 'No'},
                                                                {'label': "I don't know", 'value': 'Null'},
                                                            ],
                                                      value = 'Null'),
                                        
                                          dcc.Markdown('''**Prior stroke**'''),
                                          dcc.Dropdown(id='PriorStroke',
                                                      searchable=False,
                                                      options=[
                                                                {'label': 'Yes', 'value': 'Yes'},
                                                                {'label': 'No', 'value': 'No'},
                                                                {'label': "I don't know", 'value': 'Null'},
                                                            ],
                                                      value = 'Null'),
                                        
                                          dcc.Markdown('''**Prior bleeding:**'''),
                                          dcc.Dropdown(id='PriorBleeding',
                                                      searchable=False,
                                                      options=[
                                                                {'label': 'Yes', 'value': 'Yes'},
                                                                {'label': 'No', 'value': 'No'},
                                                                {'label': "I don't know", 'value': 'Null'},
                                                            ],
                                                      value = 'Null'),
                                        
                                          dcc.Markdown('''**Malignancy:**'''),
                                          dcc.Dropdown(id='Malignancy',
                                                      searchable=False,
                                                      options=[
                                                                {'label': 'Yes', 'value': 'Yes'},
                                                                {'label': 'No', 'value': 'No'},
                                                                {'label': "I don't know", 'value': 'Null'},
                                                            ],
                                                      value = 'Null'),
                                        
                                          dcc.Markdown('''**STEMI:**'''),
                                          dcc.Dropdown(id='STEMI',
                                                      searchable=False,
                                                      options=[
                                                                {'label': 'Yes', 'value': 'Yes'},
                                                                {'label': 'No', 'value': 'No'},
                                                                {'label': "I don't know", 'value': 'Null'},
                                                            ],
                                                      value = 'Null'),
                                        
                                          dcc.Markdown('''**NSTEMI:**'''),
                                          dcc.Dropdown(id='NSTEMI',
                                                      searchable=False,
                                                      options=[
                                                                {'label': 'Yes', 'value': 'Yes'},
                                                                {'label': 'No', 'value': 'No'},
                                                                {'label': "I don't know", 'value': 'Null'},
                                                            ],
                                                      value = 'Null'),
                                        
                                          dcc.Markdown('''**Diabetes Mellitus:**'''),
                                          dcc.Dropdown(id='DiabetesMellitus',
                                                      searchable=False,
                                                      options=[
                                                                {'label': 'Yes', 'value': 'Yes'},
                                                                {'label': 'No', 'value': 'No'},
                                                                {'label': "I don't know", 'value': 'Null'},
                                                            ],
                                                      value = 'Null'),
    
    
                                          html.Br(),
                                          html.H5("Therapeutic Variables"),
                                          dcc.Markdown('''**AAS:**'''),
                                          dcc.Dropdown(id='AAS',
                                                      searchable=False,
                                                      options=[
                                                                {'label': 'Yes', 'value': 'Yes'},
                                                                {'label': 'No', 'value': 'No'},
                                                                {'label': "I don't know", 'value': 'Null'},
                                                            ],
                                                      value = 'Null'),
                                          dcc.Markdown('''**Prasu:**'''),
                                          dcc.Dropdown(id='Prasu',
                                                      searchable=False,
                                                      options=[
                                                                {'label': 'Yes', 'value': 'Yes'},
                                                                {'label': 'No', 'value': 'No'},
                                                                {'label': "I don't know", 'value': 'Null'},
                                                            ],
                                                      value = 'Null'),
                                          dcc.Markdown('''**Tica:**'''),
                                          dcc.Dropdown(id='Tica',
                                                      searchable=False,
                                                      options=[
                                                                {'label': 'Yes', 'value': 'Yes'},
                                                                {'label': 'No', 'value': 'No'},
                                                                {'label': "I don't know", 'value': 'Null'},
                                                            ],
                                                      value = 'Null'),
                                          dcc.Markdown('''**Clopidogrel:**'''),
                                          dcc.Dropdown(id='clopidogrel',
                                                      searchable=False,
                                                      options=[
                                                                {'label': 'Yes', 'value': 'Yes'},
                                                                {'label': 'No', 'value': 'No'},
                                                                {'label': "I don't know", 'value': 'Null'},
                                                            ],
                                                      value = 'Null'),

                                          dcc.Markdown('''**ACE/ARB:**'''),
                                          dcc.Dropdown(id='ACEiARB',
                                                      searchable=False,
                                                      options=[
                                                                {'label': 'Yes', 'value': 'Yes'},
                                                                {'label': 'No', 'value': 'No'},
                                                                {'label': "I don't know", 'value': 'Null'},
                                                            ],
                                                      value = 'Null'),
                                          dcc.Markdown('''**Statin:**'''),
                                          dcc.Dropdown(id='Statin',
                                                      searchable=False,
                                                      options=[
                                                                {'label': 'Yes', 'value': 'Yes'},
                                                                {'label': 'No', 'value': 'No'},
                                                                {'label': "I don't know", 'value': 'Null'},
                                                            ],
                                                      value = 'Null'),
                                          dcc.Markdown('''**PPI:**'''),
                                          dcc.Dropdown(id='PPI',
                                                      searchable=False,
                                                      options=[
                                                                {'label': 'Yes', 'value': 'Yes'},
                                                                {'label': 'No', 'value': 'No'},
                                                                {'label': "I don't know", 'value': 'Null'},
                                                            ],
                                                      value = 'Null'),
                                          dcc.Markdown('''**OAC:**'''),
                                          dcc.Dropdown(id='OAC_total',
                                                      searchable=False,
                                                      options=[
                                                                {'label': 'Yes', 'value': 'Yes'},
                                                                {'label': 'No', 'value': 'No'},
                                                                {'label': "I don't know", 'value': 'Null'},
                                                            ],
                                                      value = 'Null'),
                                          dcc.Markdown('''**Stent Type DES:**'''),
                                          dcc.Dropdown(id='Stent_DES',
                                                      searchable=False,
                                                      options=[
                                                                {'label': 'Yes', 'value': 'Yes'},
                                                                {'label': 'No', 'value': 'No'},
                                                                {'label': "I don't know", 'value': 'Null'},
                                                            ],
                                                      value = 'Null'),
                                              dcc.Markdown('''**Prior PCI (Percutaneous Coronary Intervention):**'''),
                                          dcc.Dropdown(id='PriorPCI',
                                                      searchable=False,
                                                      options=[
                                                                {'label': 'Yes', 'value': 'Yes'},
                                                                {'label': 'No', 'value': 'No'},
                                                                {'label': "I don't know", 'value': 'Null'},
                                                            ],
                                                      value = 'Null'),
                                          dcc.Markdown('''**Branch Block:**'''),
                                          dcc.Dropdown(id='BB',
                                                      searchable=False,
                                                      options=[
                                                                {'label': 'Yes', 'value': 'Yes'},
                                                                {'label': 'No', 'value': 'No'},
                                                                {'label': "I don't know", 'value': 'Null'},
                                                            ],
                                                      value = 'Null'),
    
    
                                          html.Br(),
                                          html.H5("Angiographic Variables"),
                                          dcc.Markdown('''**Multivessel:**'''),
                                          dcc.Dropdown(id='Multivessel',
                                                      searchable=False,
                                                      options=[
                                                                {'label': 'Yes', 'value': 'Yes'},
                                                                {'label': 'No', 'value': 'No'},
                                                                {'label': "I don't know", 'value': 'Null'},
                                                            ],
                                                      value = 'Null'),
                                          dcc.Markdown('''**Complete Revascularization:**'''),
                                          dcc.Dropdown(id='completeRevasc',
                                                      searchable=False,
                                                      options=[
                                                                {'label': 'Yes', 'value': 'Yes'},
                                                                {'label': 'No', 'value': 'No'},
                                                                {'label': "I don't know", 'value': 'Null'},
                                                            ],
                                                      value = 'Null'),
                                ],
                                style={
                                #    "display": "inline-block",
                                    #"width": "78%"
                                    "verticalAlign": "top",
                                    "text-align":"justify"
                                }, id="predictors")

                      # TAB box


#+--------------------------------------------------------------------------+
#|                    TABS: Input Predictors and About                      |
#+--------------------------------------------------------------------------+
singlePredictionTab = html.Div([dcc.Tabs([                      
                                    dcc.Tab(label='Input Features', children=[predictorsInput]),  
                                ])
    
                                ],
                                className = "control-tabs",
                                style={
                                    "verticalAlign": "top",
                                    "text-align": "justify",
                                    "width": "35%",
                                    "display": "inline-block",
                                })

#+======================================================================================================+
#|                                         PREDICTION RESULTS                                           |
#+======================================================================================================+

#+--------------------------------------------------------------------------+
#|                    TABS: Prediction Results Barc                         |
#+--------------------------------------------------------------------------+
predictionResultsBarc = html.Div([
                                dcc.Tabs([
                                          dcc.Tab(label='Prediction', children=[
                                                                               html.Div([
                                                                                         dcc.Graph(id='graphPieCalibratedPred_barc'),
                                                                                         dcc.Graph(id='graphPiePred_barc'),
                                                                                         dcc.Loading(id='loading',fullscreen=True,type="circle"),
                                                                                         ],
                                                                                        style={
                                                                                            "width": "100%",
                                                                                            "verticalAlign": "top"
                                                                                            }),
                                            
                                                                              ]),
                                          dcc.Tab(label="Model's Risk Interpretation", children=[
                                                                               html.Div([
                                                                                         dcc.Graph(id='graphWf_barc'),
                                                                                         ],
                                                                                        style={
                                                                                            "width": "100%",
                                                                                            "verticalAlign": "top"
                                                                                            }),
                                                                               html.Div([
                                                                                         dcc.Graph(id='graphPred_barc'),
                                                                                         ],
                                                                                        style={
                                                                                            "width": "100%",
                                                                                            "verticalAlign": "top"
                                                                                            }),
                                                                               html.Div([
                                                                                         dcc.Graph(id='graphContrib_barc'),
                                                                                         html.Div(id='graphContribNotes_barc')
                                                                                         ],
                                                                                        style={
                                                                                            "width": "100%",
                                                                                            "verticalAlign": "top"
                                                                                            })
                                                                             ]),
                                          dcc.Tab(label="Model's Parameters", children=[
                                                                               html.Div([
                                                                                         dcc.Graph(id='graphLVEF_barc'),
                                                                                         html.P("Regression Equation:"),
                                                                                         dcc.Markdown('''DeltaRisk = -0.008785•LVEF + 0.4289''', className="formula-style"),
                                                                                         ],
                                                                                        style={
                                                                                            "display": "inline-block",
                                                                                            "width": "100%",
                                                                                            "verticalAlign": "top"
                                                                                            }),
                                                                               html.Div([
                                                                                         dcc.Graph(id='graphAge_barc'),
                                                                                         html.P("Regression Equation:"),
                                                                                         dcc.Markdown('''DeltaRisk = +0.006626•Age - 0.4537''', className="formula-style"),
                                                                                         ],
                                                                                        style={
                                                                                            "display": "inline-block",
                                                                                            "width": "100%",
                                                                                            "verticalAlign": "top"
                                                                                            }),
                                                                               html.Div([
                                                                                         dcc.Graph(id='graphEGFR_barc'),
                                                                                         html.P("Regression Equation:"),
                                                                                         dcc.Markdown('''DeltaRisk = -0.0007235•eGFR + 0.05799''', className="formula-style"),
                                                                                         ],
                                                                                        style={
                                                                                            "display": "inline-block",
                                                                                            "width": "100%",
                                                                                            "verticalAlign": "top"
                                                                                            }),
                                                                               ])
                                          ])
                                ],
                                className = "control-tabs",
                                style={
                                    "verticalAlign": "top",
                                    "width": "98%",
                                    "display": "inline-block",
                                })

#+--------------------------------------------------------------------------+
#|                    TABS: Prediction Results DEATH                        |
#+--------------------------------------------------------------------------+
predictionResultsDeath = html.Div([
                                dcc.Tabs([
                                          dcc.Tab(label='Prediction', children=[
                                                                               html.Div([
                                                                                         dcc.Graph(id='graphPieCalibratedPred_death'),
                                                                                         dcc.Graph(id='graphPiePred_death')
                                                                                         ],
                                                                                        style={
                                                                                            "width": "100%",
                                                                                            "verticalAlign": "top"
                                                                                            }),
                                            
                                                                              ]),
                                          dcc.Tab(label="Model's Risk Interpretation", children=[
                                                                               html.Div([
                                                                                         dcc.Graph(id='graphWf_death'),
                                                                                         ],
                                                                                        style={
                                                                                            "width": "100%",
                                                                                            "verticalAlign": "top"
                                                                                            }),
                                                                               html.Div([
                                                                                         dcc.Graph(id='graphPred_death'),
                                                                                         ],
                                                                                        style={
                                                                                            "width": "100%",
                                                                                            "verticalAlign": "top"
                                                                                            }),
                                                                               html.Div([
                                                                                         dcc.Graph(id='graphContrib_death'),
                                                                                         html.Div(id='graphContribNotes_death')
                                                                                         ],
                                                                                        style={
                                                                                            "width": "100%",
                                                                                            "verticalAlign": "top"
                                                                                            })
                                                                             ]),
                                          dcc.Tab(label="Model's Parameters", children=[
                                                                               html.Div([
                                                                                         dcc.Graph(id='graphLVEF_death'),
                                                                                         html.P("Regression Equation:"),
                                                                                         dcc.Markdown('''DeltaRisk = -0.008785•LVEF + 0.4289''', className="formula-style"),
                                                                                         ],
                                                                                        style={
                                                                                            "display": "inline-block",
                                                                                            "width": "100%",
                                                                                            "verticalAlign": "top"
                                                                                            }),
                                                                               html.Div([
                                                                                         dcc.Graph(id='graphAge_death'),
                                                                                         html.P("Regression Equation:"),
                                                                                         dcc.Markdown('''DeltaRisk = +0.006626•Age - 0.4537''', className="formula-style"),
                                                                                         ],
                                                                                        style={
                                                                                            "display": "inline-block",
                                                                                            "width": "100%",
                                                                                            "verticalAlign": "top"
                                                                                            }),
                                                                               html.Div([
                                                                                         dcc.Graph(id='graphEGFR_death'),
                                                                                         html.P("Regression Equation:"),
                                                                                         dcc.Markdown('''DeltaRisk = -0.0007235•eGFR + 0.05799''', className="formula-style"),
                                                                                         ],
                                                                                        style={
                                                                                            "display": "inline-block",
                                                                                            "width": "100%",
                                                                                            "verticalAlign": "top"
                                                                                            }),
                                                                               ])
                                          ])
                                ],
                                className = "control-tabs",
                                style={
                                    "verticalAlign": "top",
                                    "width": "98%",
                                    "display": "inline-block",
                                })




#+--------------------------------------------------------------------------+
#|                    TABS: Model available                                 |
#+--------------------------------------------------------------------------+
modelsAvailable = html.Div([
                                dcc.Tabs([
                                          dcc.Tab(label='Model Bleeding', children=[
                                                                               html.Div([
                                                                                         predictionResultsBarc,
                                                                                         ]),
                                            
                                                                              ]),
                                          dcc.Tab(label="Model Death", children=[
                                                                               html.Div([
                                                                                         predictionResultsDeath,
                                                                                         ]),
                                                                              ]),
                                          ])
                                ],
                                className = "control-tabs",
                                style={
                                    "verticalAlign": "top",
                                    "width": "50%",
                                    "display": "inline-block",
                                })


 
    


#+======================================================================================================+
#|                                         PDTA TAB EVOLUTION INPUT                                         |
#+======================================================================================================+
PDTATab = html.Div([dcc.Tabs([
                                dcc.Tab(label='BLEEDING PDTA', children=[html.Div(aboutPDTA,
                                                                            style={
                                                                                "verticalAlign": "top",
                                                                                "text-align": "justify",
                                                                                "width": "100%",
                                                                                "display": "inline-block",
                                                                            }),
                                                                         
                                                                         html.Div([
                                                                                 dcc.Graph(id='graphPathPDTA'),
                                                                                 ],
                                                                                style={
                                                                                    "width": "100%",
                                                                                    "verticalAlign": "top"
                                                                                    }),
                                                                         
                                                                         html.Div([
                                                                                 dcc.Graph(id='graphPathPDTAModel'),
                                                                                 ],
                                                                                style={
                                                                                    "width": "100%",
                                                                                    "verticalAlign": "top"
                                                                                    }),
                                                                        ]),  
                                ])],
                                className = "lowercontrol-tabs",
                                style={
                                    "verticalAlign": "top",
                                    "text-align": "justify",
                                    "width": "92%",
                                    "display": "inline-block",
                                })

#+======================================================================================================+
#|                                         TIME EVOLUTION INPUT                                         |
#+======================================================================================================+
timeEvolutionInput = html.Div([dcc.Tabs([
                                    dcc.Tab(label='About', children=aboutTimeAnalysis),
                                    dcc.Tab(label='Upload File', children=[html.Div([dcc.Upload(id='datatable-upload',
                                                                                                children=html.Div(['Drag and Drop or ',
                                                                                                                   html.A('Select Files'),
                                                                                                                  ]),
                                                                                                className = "input-table",
                                                                                                style={
                                                                                                        'width': '98%', 'height': '60px', 'lineHeight': '60px',
                                                                                                        'borderWidth': '1.5px', 'borderStyle': 'dashed', 'border-color': '3D4F58',
                                                                                                        'borderRadius': '5px', 'textAlign': 'center', 'margin': '0px', 'padding': '0%',
                                                                                                    },),
                                                                                    html.Br(),  
                                                                                    ' Or try our ',
                                                                                    html.Button('DEMO 🔍', id='upload-data', n_clicks=0, className = "button"),
                                                                                    html.Br(),
                                                                                    dash_table.DataTable(id='datatable-upload-container'),
                                                                          ],className = "table-box",
                                                                            style={"display": "inline-block",
                                                                                   "text-align": "center",
                                                                                   "verticalAlign": "top",
                                                                                   "width": "100%",})
                                        ]),  
                                ])],
                                className = "lowercontrol-tabs",
                                style={
                                    "verticalAlign": "top",
                                    "text-align": "justify",
                                    "width": "92%",
                                    "display": "inline-block",
                                })


#+======================================================================================================+
#|                                       TIME EVOLUTION OUTPUT                                          |
#+======================================================================================================+
#+--------------------------------------------------------------------------+
#|                              MODEL BLEEDING                              |
#+--------------------------------------------------------------------------+
timeEvolutionOutputBarc = html.Div([dcc.Tabs([
                                    dcc.Tab(label='Risk Evolution', children=[
                                                                               html.Div([
                                                                                         dcc.Graph(id='graphRiskEvol'),
                                                                                         ],className = "graphout-box",
                                                                            style={"display": "inline-block",
                                                                                   "verticalAlign": "top",
                                                                                   "width": "100%",})
                                        
                                    ]),
                                    dcc.Tab(label='Features Delta Evolution', children=[
                                                                               html.Div([
                                                                                         dcc.Graph(id='graphFeaturesEvol'),
                                                                                         ],className = "graphout-box",
                                                                            style={"display": "inline-block",
                                                                                   "verticalAlign": "top",
                                                                                   "width": "100%",})
                                        
                                    ]),
                                                                     
                                    dcc.Tab(label='3D Features Risk Evolution', children=[html.Div([dcc.Graph(id='graphTemporal'),
                                                                          ],className = "graphout-box",
                                                                            style={"display": "inline-block",
                                                                                   "verticalAlign": "top",
                                                                                   "width": "100%",})
                                        ]),  
                                ])],
                                className = "lowercontrol-tabs",
                                style={
                                    "verticalAlign": "top",
                                    "text-align": "justify",
                                    "width": "92%",
                                    "display": "inline-block",
                                })

#+--------------------------------------------------------------------------+
#|                             MODEL DEATH                                  |
#+--------------------------------------------------------------------------+
timeEvolutionOutputDeath = html.Div([dcc.Tabs([
                                    dcc.Tab(label='Risk Evolution', children=[
                                                                               html.Div([
                                                                                         dcc.Graph(id='graphRiskEvolDeath'),
                                                                                         ],className = "graphout-box",
                                                                            style={"display": "inline-block",
                                                                                   "verticalAlign": "top",
                                                                                   "width": "100%",})
                                        
                                    ]),
                                    dcc.Tab(label='Features Delta Evolution', children=[
                                                                               html.Div([
                                                                                         dcc.Graph(id='graphFeaturesEvolDeath'),
                                                                                         ],className = "graphout-box",
                                                                            style={"display": "inline-block",
                                                                                   "verticalAlign": "top",
                                                                                   "width": "100%",})
                                        
                                    ]),
                                                                     
                                    dcc.Tab(label='3D Features Risk Evolution', children=[html.Div([dcc.Graph(id='graphTemporalDeath'),
                                                                          ],className = "graphout-box",
                                                                            style={"display": "inline-block",
                                                                                   "verticalAlign": "top",
                                                                                   "width": "100%",})
                                        ]),  
                                ])],
                                className = "lowercontrol-tabs",
                                style={
                                    "verticalAlign": "top",
                                    "text-align": "justify",
                                    "width": "92%",
                                    "display": "inline-block",
                                })


#+======================================================================================================+
#|                                       TIME EVOLUTION OUTPUT                                          |
#+======================================================================================================+
timeEvolutionOutput = html.Div([
                                dcc.Tabs([
                                          dcc.Tab(label='Model Bleeding', children=[
                                                                               html.Div([
                                                                                         timeEvolutionOutputBarc,
                                                                                         ]),
                                            
                                                                              ]),
                                          dcc.Tab(label="Model Death", children=[
                                                                               html.Div([
                                                                                         timeEvolutionOutputDeath,
                                                                                         ]),
                                                                              ]),
                                          ])
                                ],
                                className = "control-tabs",
                                style={
                                    "verticalAlign": "top",
                                    "text-align": "justify",
                                    "width": "92%",
                                    "display": "inline-block",
                                })

#+======================================================================================================+
#|                                     TITLE BOX AND LOGOS                                              |
#+======================================================================================================+
bottomBox = html.Div(
    children=[ 
        
        
        html.Div(children = [
            html.P("From ", className = "typography-footprint", style={"display": "inline"}),
            html.P(" YOU FOR ALL ", className = "typography-footprintY4A", style={"display": "inline"}),
            html.P(" Team with ❤️", className = "typography-footprint", style={"display": "inline"})
            ],
    style={"display": "inline-block",
           "verticalAlign": "top",
           "width": "100%",}),
        
            ],
    className = "bottom-box",
    style={"display": "inline",}
)

#+======================================================================================================+
#|                                               BODY                                                   |
#+======================================================================================================+
app.layout= html.Div([
                      titleBox,
                      html.Div([
                      aboutTabs,
                      ],style = {"text-align":"center"}, className = "lower-box"),
    
                      html.Div([
                      singlePredictionTab,
                      modelsAvailable, #predictionResults,
                      ],style = {"text-align":"center"}, className = "central-box"),
                       
                      html.Div([
                      PDTATab,
                      timeEvolutionInput,
                      timeEvolutionOutput
                      ],style = {"text-align":"center"}, className = "lower-box"),
                      bottomBox
],
                      id='app-page-content',
                      style = {"text-align":"center"})

app.css.config.serve_locally = True
app.scripts.config.serve_locally = True



#+======================================================================================================+
#|                                   APPLICATIONS CALLBACKS                                             |
#+======================================================================================================+
#@app.callback(Output("loading-icon", "children"))
#+------------------------------------------------------------------------------------------------------+
#|                              Update the table and load the plot                                      |
#+------------------------------------------------------------------------------------------------------+

@app.callback(Output('datatable-upload-container', 'data'),
              Output('datatable-upload-container', 'columns'),
              Output('graphRiskEvol', 'figure'),
              Output('graphFeaturesEvol', 'figure'),
              Output('graphTemporal', 'figure'),
              Output('graphRiskEvolDeath', 'figure'),
              Output('graphFeaturesEvolDeath', 'figure'),
              Output('graphTemporalDeath', 'figure'),
              [Input('datatable-upload', 'contents'),
               Input('upload-data', 'n_clicks')],
              State('datatable-upload', 'filename'))

def update_output(contents, n_clicks, filename):
    ctx = dash.callback_context
    if not ctx.triggered:
        trigger_id = 'No clicks yet'
    else:
        trigger_id = ctx.triggered[0]['prop_id'].split('.')[0]
    
    ## At first check if the button has been clicked
    
        
    ## If there are no content in the table return the image with the empty folder
    if (contents is None) and (trigger_id != 'upload-data'):
        fig = px.imshow(img)
        fig.update_layout(coloraxis_showscale=False)
        fig.update_traces(hoverinfo='skip', hovertemplate=None)
        fig.update_xaxes(showticklabels=False)
        fig.update_yaxes(showticklabels=False)
        return [{}], [], fig, fig, fig, fig, fig, fig
    else: 
        # Se i dati sono interni carica il dataset altrimenti attendi l'inserimento
        if (trigger_id == 'upload-data'):
            temporalEvolution = pd.read_csv(projectRoot + "/data/featuresTemporalEvolutionDEMO.csv")
        else:
            temporalEvolution = parse_contents(contents, filename)

    # Analisi BARC
    #------------------------------------------------
    riskEvolution = {"Entry":[], "RiskEvolution": []}
    pred_proba_test_patient_barc, ftrsDelta_barc, positiveFtrsDelta_barc, negativeFtrsDelta_barc = ShapModelBarc.predict({'Age': list(temporalEvolution["Age"])[0],  
                                                                   #'Hb': Hb,
                                                                   #'CRevasc': list(temporalEvolution["Complete Revasc."])[0],
                                                                   'LVEF': list(temporalEvolution["LVEF"])[0],
                                                                   'eGFR (MDRD)': list(temporalEvolution["eGFR"])[0],  
                                                                   'Female': list(temporalEvolution["Sex"])[0],
                                                                   'hypertension':list(temporalEvolution["Hypertension"])[0]})
    
    temporalContrib = pd.DataFrame(ftrsDelta_barc, index=[0])
    riskEvolution["RiskEvolution"].append(round(pred_proba_test_patient_barc,4))
    riskEvolution["Entry"].append(0)

    for i in range(1,len(temporalEvolution)):
        pred_proba_test_patient_barc, ftrsDelta_barc, positiveFtrsDelta_barc, negativeFtrsDelta_barc = ShapModelBarc.predict({'Age': list(temporalEvolution["Age"])[i],  
                                                                       #'Hb': Hb,
                                                                       'CRevasc': list(temporalEvolution["Complete Revasc."])[i],
                                                                       'LVEF': list(temporalEvolution["LVEF"])[i],
                                                                       'eGFR (MDRD)': list(temporalEvolution["eGFR"])[i],  
                                                                       'Female': list(temporalEvolution["Sex"])[i],
                                                                       'hypertension':list(temporalEvolution["Hypertension"])[i]})
        contribution = pd.DataFrame(ftrsDelta_barc, index=[0])
        riskEvolution["RiskEvolution"].append(round(pred_proba_test_patient_barc,4))
        riskEvolution["Entry"].append(i)
        temporalContrib = pd.concat([temporalContrib,contribution])
        temporalContrib.reset_index(inplace=True, drop = True)
        
        
    figFeaturesEvol = deltaRiskEvolutionGraph(temporalContrib)
    figRiskEvolution = plotRiskEvolution(riskEvolution)
    
    temporalContrib2 = {"Entry":[], "Feature":[], "Value":[]}
    for feature in list(temporalContrib.columns):
      for entry, row in temporalContrib.iterrows():
        temporalContrib2["Entry"].append(entry*1.0)
        temporalContrib2["Feature"].append(feature)
        temporalContrib2["Value"].append(row[feature])

    temporalContrib2 = pd.DataFrame.from_dict(temporalContrib2)
    
    fig3D = temporalContrib3D(temporalContrib2)
    
    
    # ANALISI DEATH
    # -------------------------------------------------------------------
    
    riskEvolution = {"Entry":[], "RiskEvolution": []}
    pred_proba_test_patient_death, ftrsDelta_death, positiveFtrsDelta_death, negativeFtrsDelta_death = ShapModelDeath.predict({'Age': list(temporalEvolution["Age"])[0],
                                                                                                                              #'Hb': Hb,
                                                                                                                              'LVEF': list(temporalEvolution["LVEF"])[0], 
                                                                                                                              #'creatinine': Creatinine, 
                                                                                                                              'eGFR (MDRD)': list(temporalEvolution["eGFR"])[0],
                                                                                                                              #"VascularAccess (0=radial,1=femoral)" = VascularAccess (0=radial,1=femoral)  
                                                                                                                              #"Multivessel" = Multivessel
                                                                                                                              #"Stent_DES" = Stent_DES  
                                                                                                                              #"PPI" = PPI"
                                                                                                                              #"UA-nstemi" = UA-nstemi 
                                                                                                                              "Complete_revasc": list(temporalEvolution["Complete Revasc."])[0],
                                                                                                                              #"PriorAMI": PrAMI,
                                                                                                                              #"ACEiARB" = ACEiARB
                                                                                                                              #"hyperlipidemia": Hyperlip,
                                                                                                                              #"Diabetes mellitus (both)": DMellitus,  
                                                                                                                              "Female": list(temporalEvolution["Sex"])[0],  
                                                                                                                              "hypertension": list(temporalEvolution["Hypertension"])[0], 
                                                                                                                              #"PriorStroke": PrStroke,
                                                                                                                              #"Malignancy": Malignancy,
                                                                                                                              #"PriorBleeding": PrBleed
                                                                                                                              })
      
    temporalContrib = pd.DataFrame(ftrsDelta_death, index=[0])
    riskEvolution["RiskEvolution"].append(round(pred_proba_test_patient_death,4))
    riskEvolution["Entry"].append(0)

    for i in range(1,len(temporalEvolution)):
        pred_proba_test_patient_death, ftrsDelta_death, positiveFtrsDelta_death, negativeFtrsDelta_death = ShapModelDeath.predict({'Age': list(temporalEvolution["Age"])[i],
                                                                                                                                  #'Hb': Hb,
                                                                                                                                  'LVEF': list(temporalEvolution["LVEF"])[i], 
                                                                                                                                  #'creatinine': Creatinine, 
                                                                                                                                  'eGFR (MDRD)': list(temporalEvolution["eGFR"])[i],
                                                                                                                                  #"VascularAccess (0=radial,1=femoral)" = VascularAccess (0=radial,1=femoral)  
                                                                                                                                  #"Multivessel" = Multivessel
                                                                                                                                  #"Stent_DES" = Stent_DES  
                                                                                                                                  #"PPI" = PPI"
                                                                                                                                  #"UA-nstemi" = UA-nstemi 
                                                                                                                                  "Complete_revasc": list(temporalEvolution["Complete Revasc."])[i],
                                                                                                                                  #"PriorAMI": PrAMI,
                                                                                                                                  #"ACEiARB" = ACEiARB
                                                                                                                                  #"hyperlipidemia": Hyperlip,
                                                                                                                                  #"Diabetes mellitus (both)": DMellitus,  
                                                                                                                                  "Female": list(temporalEvolution["Sex"])[i],  
                                                                                                                                  "hypertension": list(temporalEvolution["Hypertension"])[i], 
                                                                                                                                  #"PriorStroke": PrStroke,
                                                                                                                                  #"Malignancy": Malignancy,
                                                                                                                                  #"PriorBleeding": PrBleed
                                                                                                                                  })
        contribution = pd.DataFrame(ftrsDelta_death, index=[0])
        riskEvolution["RiskEvolution"].append(round(pred_proba_test_patient_death,4))
        riskEvolution["Entry"].append(i)
        temporalContrib = pd.concat([temporalContrib,contribution])
        temporalContrib.reset_index(inplace=True, drop = True)
        
        
    figFeaturesEvolDeath = deltaRiskEvolutionGraph(temporalContrib)
    figRiskEvolutionDeath = plotRiskEvolution(riskEvolution)
    
    temporalContrib2 = {"Entry":[], "Feature":[], "Value":[]}
    for feature in list(temporalContrib.columns):
      for entry, row in temporalContrib.iterrows():
        temporalContrib2["Entry"].append(entry*1.0)
        temporalContrib2["Feature"].append(feature)
        temporalContrib2["Value"].append(row[feature])

    temporalContrib2 = pd.DataFrame.from_dict(temporalContrib2)
    
    fig3DDeath = temporalContrib3D(temporalContrib2)
    
    
    return temporalEvolution.to_dict('records'), [{"name": i, "id": i} for i in temporalEvolution.columns],  figRiskEvolution, figFeaturesEvol, fig3D, figRiskEvolutionDeath, figFeaturesEvolDeath, fig3DDeath

#+------------------------------------------------------------------------------------------------------+
#|     Update the predicted score risk and plots wen a new featuresis inserted/modified                 |
#+------------------------------------------------------------------------------------------------------+
#@app.callback(Output("loading-icon", "children"))

@app.callback(Output('loading', 'parent_style'),
              Output('graphPieCalibratedPred_barc', 'figure'),
              Output('graphPiePred_barc', 'figure'),
              Output('graphPred_barc', 'figure'),
              Output('graphContrib_barc', 'figure'),
              Output('graphWf_barc', 'figure'),
              Output('graphContribNotes_barc', 'children'),
              Output('graphPieCalibratedPred_death', 'figure'),
              Output('graphPiePred_death', 'figure'),
              Output('graphPred_death', 'figure'),
              Output('graphContrib_death', 'figure'),
              Output('graphWf_death', 'figure'),
              Output('graphContribNotes_death', 'children'),
              Output('graphPathPDTA', 'figure'),
              Output('graphPathPDTAModel', 'figure'),
              [Input('AgeSlider', 'value'), 
               Input('LVEFNull', 'value'), 
               Input('LVEFSlider', 'value'),
               Input('EGFRNull', 'value'),
               Input('EGFRSlider', 'value'),
               Input('HbNull', 'value'), 
               Input('HbSlider', 'value'), 
               Input('hypertension', 'value'), 
               Input('completeRevasc', 'value'), 
               Input('BB', 'value'), 
               Input('sex', 'value'),
               Input('ethnicity', 'value'),
               Input('Hyperlipidemia', 'value'),
               Input('PAD', 'value'),
               Input('PriorAMI', 'value'),
               Input('PriorCABG', 'value'),
               Input('PriorStroke', 'value'),
               Input('PriorBleeding', 'value'),
               Input('Malignancy', 'value'),
               Input('STEMI', 'value'),
               Input('NSTEMI', 'value'),
               Input('DiabetesMellitus', 'value'),
               Input('AAS', 'value'),
               Input('Prasu', 'value'),
               Input('Tica', 'value'),
               Input('clopidogrel', 'value'),
               Input('ACEiARB', 'value'),
               Input('Statin', 'value'),
               Input('PPI', 'value'),
               Input('Stent_DES', 'value'),
               Input('PriorPCI', 'value'),
               Input('OAC_total', 'value'),
               Input('Multivessel', 'value')])

def updatePred(age_val, LVEFNull_val, LVEF_val, eGFRNull_val, eGFR_val, HbNull_val, Hb_val, HyperT_val, cRevasc_val, BB_val, sex_val, ethnicity_val,
              Hyperlip_val, PAD_val, PrAMI_val, PrCABG_val, PrStroke_val, PrBleed_val, Malignancy_val, STEMI_val, NSTEMI_val, DMellitus_val,
              AAS_val, Prasu_val, Tica_val, clopidogrel_val, ACEiARB_val, Statin_val, PPI_val, Stent_DES_val, PriorPCI_val, OAC_total_val, Multivessel_val):
    # Gloabal input features
    global negativeContrib
    global positiveContrib
    global age
    global LVEF
    global eGFR
    global eGFR_temp
    global cRevasc
    global sex
    global ethnicity
    global Creatinine
    global Hb
    
    global HyperT
    global Hyperlip
    global PAD
    global PrAMI
    global PrCABG
    global PrStroke
    global PrBleed
    global Malignancy
    global STEMI
    global NSTEMI
    global DMellitus
    
    global BB
    
    global AAS
    global Prasu
    global Tica
    global clopidogrel
    global ACEiARB
    global Statin
    global PPI
    global Stent_DES
    global PriorPCI
    global OAC_total
    global Multivessel
    
    
    # Extract the widget id that trigger the updatePred Callback
    ctx = dash.callback_context
    if not ctx.triggered:
        trigger_id = 'No clicks yet'
    else:
        trigger_id = ctx.triggered[0]['prop_id'].split('.')[0]

    # Based on which widget trigger the function update the global parameteres
    if trigger_id == 'AgeSlider':
        age = age_val
            
    elif trigger_id == 'LVEFNull':
        if len(LVEFNull_val)>0:
            LVEF = None
        else:
            LVEF = LVEF_val
            
    elif trigger_id == 'LVEFSlider':
        if (LVEFNull_val is not None) and len(LVEFNull_val)>0:
              LVEF = None
        else:
              LVEF = LVEF_val

    elif trigger_id == 'EGFRNull':
        if len(eGFRNull_val)>0:
            eGFR = None
        else:
            eGFR = eGFR_val
    elif trigger_id == 'EGFRSlider':
        if (eGFRNull_val is not None) and len(eGFRNull_val)>0:
            eGFR = None
        else:
            eGFR = eGFR_val
                      
    elif trigger_id == 'HbNull':
        if len(HbNull_val)>0:
            Hb = None
        else:
            Hb = Hb_val
            
    elif trigger_id == 'HbSlider':
        if (HbNull_val is not None) and len(HbNull_val)>0:
            Hb = None
        else:
            Hb = Hb_val
            
    elif trigger_id == 'sex':
        if sex_val == "Female":
            Female = 1
        elif sex_val == "Male":
            Female = 0
    
    elif trigger_id == 'ethnicity':
        if ethnicity_val == "Black":
            ethnicity = 1
        elif ethnicity_val == "White":
            ethnicity = 0
            

    elif trigger_id == 'hypertension':
        if HyperT_val == "Yes": HyperT = 1
        elif HyperT_val == "No": HyperT = 0
        elif HyperT_val == "Null": HyperT = None
    elif trigger_id == 'Hyperlipidemia':
        if Hyperlip_val == "Yes": Hyperlip = 1
        elif Hyperlip_val == "No": Hyperlip = 0
        elif Hyperlip_val == "Null": Hyperlip = None
    elif trigger_id == 'PAD':
        if PAD_val == "Yes": PAD = 1
        elif PAD_val == "No": PAD = 0
        elif PAD_val == "Null": PAD = None
    elif trigger_id == 'PriorAMI':
        if PrAMI_val == "Yes": PrAMI = 1
        elif PrAMI_val == "No": PrAMI = 0
        elif PrAMI_val == "Null": PrAMI = None
    elif trigger_id == 'PriorCABG':
        if PrCABG_val == "Yes": PrCABG = 1
        elif PrCABG_val == "No": PrCABG = 0
        elif PrCABG_val == "Null": PrCABG = None
    elif trigger_id == 'PriorStroke':
        if PrStroke_val == "Yes": PrStroke = 1
        elif PrStroke_val == "No": PrStroke = 0
        elif PrStroke_val == "Null": PrStroke = None
    elif trigger_id == 'PriorBleeding':
        if PrBleed_val == "Yes": PrBleed = 1
        elif PrBleed_val == "No": PrBleed = 0
        elif PrBleed_val == "Null": PrBleed = None
    elif trigger_id == 'Malignancy':
        if Malignancy_val == "Yes": Malignancy = 1
        elif Malignancy_val == "No": Malignancy = 0
        elif Malignancy_val == "Null": Malignancy = None
    elif trigger_id == 'STEMI':
        if STEMI_val == "Yes": STEMI = 1
        elif STEMI_val == "No": STEMI = 0
        elif STEMI_val == "Null": STEMI = None
    elif trigger_id == 'NSTEMI':
        if NSTEMI_val == "Yes": NSTEMI = 1
        elif NSTEMI_val == "No": NSTEMI = 0
        elif NSTEMI_val == "Null": NSTEMI = None
    elif trigger_id == 'DiabetesMellitus':
        if DMellitus_val == "Yes": DMellitus = 1
        elif DMellitus_val == "No": DMellitus = 0
        elif DMellitus_val == "Null": DMellitus = None   
    
    # THERAPEUTIC    
    elif trigger_id == 'completeRevasc':
        if cRevasc_val == "Yes": cRevasc = 1
        elif cRevasc_val == "No": cRevasc = 0
        elif cRevasc_val == "Null": cRevasc = None    
    elif trigger_id == 'BB':
        if BB_val == "Yes": BB = 1
        elif BB_val == "No": BB = 0
        elif BB_val == "Null": BB = None
            
    elif trigger_id == 'AAS':
        if AAS_val == "Yes": AAS = 1
        elif AAS_val == "No": AAS = 0
        elif AAS_val == "Null": AAS = None
    elif trigger_id == 'Prasu':
        if Prasu_val == "Yes": Prasu = 1
        elif Prasu_val == "No": Prasu = 0
        elif Prasu_val == "Null": Prasu = None
    elif trigger_id == 'Tica':
        if Tica_val == "Yes": Tica = 1
        elif Tica_val == "No": Tica = 0
        elif Tica_val == "Null": Tica = None
    elif trigger_id == 'clopidogrel':
        if clopidogrel_val == "Yes": clopidogrel = 1
        elif clopidogrel_val == "No": clopidogrel = 0
    elif trigger_id == 'ACEiARB':
        if ACEiARB_val == "Yes": ACEiARB = 1
        elif ACEiARB_val == "No": ACEiARB = 0
        elif ACEiARB_val == "Null": ACEiARB = None
    elif trigger_id == 'Statin':
        if Statin_val == "Yes": Statin = 1
        elif Statin_val == "No": Statin = 0
        elif Statin_val == "Null": Statin = None
    elif trigger_id == 'PriorPCI':
        if PriorPCI_val == "Yes": PriorPCI = 1
        elif PriorPCI_val == "No": PriorPCI = 0
        elif PriorPCI_val == "Null": PriorPCI = None
    elif trigger_id == 'Stent_DES':
        if Stent_DES_val == "Yes": Stent_DES = 1
        elif Stent_DES_val == "No": Stent_DES = 0
        elif Stent_DES_val == "Null": Stent_DES = None
    elif trigger_id == 'PPI':
        if PPI_val == "Yes": PPI = 1
        elif PPI_val == "No": PPI = 0
        elif PPI_val == "Null": PPI = None
    elif trigger_id == 'OAC_total':
        if OAC_total_val == "Yes": OAC_total = 1
        elif OAC_total_val == "No": OAC_total = 0
        elif OAC_total_val == "Null": OAC_total = None
    elif trigger_id == 'Multivessel':
        if Multivessel_val == "Yes": Multivessel = 1
        elif Multivessel_val == "No": Multivessel = 0
        elif Multivessel_val == "Null": Multivessel = None
    
    ## COMPUTE THE NEW PREDICTION
    #+-----------------------------------------------------------------------------------+
    #|                                    BARC                                           |
    #+-----------------------------------------------------------------------------------+
    # Compute the prediction probability associated with the updated values and the risk contributions of each values
     
    pred_proba_test_patient_barc, ftrsDelta_barc, positiveFtrsDelta_barc, negativeFtrsDelta_barc = ShapModelBarc.predict({'Age': age,
                                                                                                      'Hb': Hb,
                                                                                                      'LVEF': LVEF,  
                                                                                                      'eGFR (MDRD)': eGFR,
                                                                                                      'Female': sex,
                                                                                                      #"VascularAccess (0=radial,1=femoral)" = VascularAccess (0=radial,1=femoral)  
                                                                                                      "Multivessel": Multivessel,
                                                                                                      "Stent_DES": Stent_DES, 
                                                                                                      "PPI": PPI,
                                                                                                      #"UA-nstemi" = UA-nstemi 
                                                                                                      "Complete_revasc": cRevasc,
                                                                                                      "PriorAMI": PrAMI,
                                                                                                      "ACEiARB": ACEiARB,
                                                                                                      "hyperlipidemia": Hyperlip,
                                                                                                      "Diabetes mellitus (both)": DMellitus,  
                                                                                                      "Female": sex,  
                                                                                                      "hypertension": HyperT, 
                                                                                                      "PriorStroke": PrStroke,
                                                                                                      "Malignancy": Malignancy,
                                                                                                      "PriorBleeding": PrBleed})
    
    
    # Compute and update the Pie Chart Graph with the predictions
    figPiePred_barc = riskPieChartBarc(pred_proba_test_patient_barc)
    figPieCalibratedPred_barc = calibratedRiskPieChartBarc(pred_proba_test_patient_barc, iso_reg_barc)
    
    # Compute and update the Sunnburst Chart Graph with the predictions (you need to convert the positive/negative deltas in dataframe)
    figPred_barc = sunBurstPredGraph(pd.DataFrame(negativeFtrsDelta_barc, index=[0]), pd.DataFrame(positiveFtrsDelta_barc, index=[0]))
    
    # Compute and update the sunburst graph for the contribution and the list of used/missing faeatures 
    figContrib_barc, usedFeatures_barc, usedFeaturesImportance_barc, missingFeatures_barc, missingFeaturesImportance_barc = sunBurstContribGraph(pd.DataFrame(negativeFtrsDelta_barc, index=[0]),
                                                                                                                                                 pd.DataFrame(positiveFtrsDelta_barc, index=[0]),
                                                                                                                                                ShapModelBarc)
    # Select and Display comments
    if sum(usedFeaturesImportance_barc)/(sum(usedFeaturesImportance_barc)+sum(missingFeaturesImportance_barc)) < 0.60:
        contribNotes_barc = html.P("")
    else:
        contribNotes_barc = html.P("")
        
    # Compute the waterfall plot
    figWF_barc = waterFallGraph(ftrsDelta_barc)
    
    #+-----------------------------------------------------------------------------------+
    #|                                    Death                                          |
    #+-----------------------------------------------------------------------------------+
    # Compute the prediction probability associated with the updated values and the risk contributions of each values
     
    pred_proba_test_patient_death, ftrsDelta_death, positiveFtrsDelta_death, negativeFtrsDelta_death = ShapModelDeath.predict({'Age': age,
                                                                                                      'Hb': Hb,
                                                                                                      'LVEF': LVEF, 
                                                                                                      #'creatinine': Creatinine, 
                                                                                                      'eGFR (MDRD)': eGFR,
                                                                                                      'Female': sex,
                                                                                                      #"VascularAccess (0=radial,1=femoral)" = VascularAccess (0=radial,1=femoral)  
                                                                                                      #"Multivessel" = Multivessel
                                                                                                      #"Stent_DES" = Stent_DES  
                                                                                                      #"PPI" = PPI"
                                                                                                      #"UA-nstemi" = UA-nstemi 
                                                                                                      "Complete_revasc": cRevasc,
                                                                                                      "PriorAMI": PrAMI,
                                                                                                      #"ACEiARB" = ACEiARB
                                                                                                      "hyperlipidemia": Hyperlip,
                                                                                                      "Diabetes mellitus (both)": DMellitus,  
                                                                                                      "Female": sex,  
                                                                                                      "hypertension": HyperT, 
                                                                                                      "PriorStroke": PrStroke,
                                                                                                      "Malignancy": Malignancy,
                                                                                                      "PriorBleeding": PrBleed})
    
    
    # Compute and update the Pie Chart Graph with the predictions
    figPiePred_death = riskPieChartDeath(pred_proba_test_patient_death)
    figPieCalibratedPred_death = calibratedRiskPieChartDeath(pred_proba_test_patient_death, iso_reg_death)
    
    # Compute and update the Sunnburst Chart Graph with the predictions (you need to convert the positive/negative deltas in dataframe)
    figPred_death = sunBurstPredGraph(pd.DataFrame(negativeFtrsDelta_death, index=[0]), pd.DataFrame(positiveFtrsDelta_death, index=[0]))
    
    # Compute and update the sunburst graph for the contribution and the list of used/missing faeatures 
    figContrib_death, usedFeatures_death, usedFeaturesImportance_death, missingFeatures_death, missingFeaturesImportance_death = sunBurstContribGraph(pd.DataFrame(negativeFtrsDelta_death, index=[0]),
                                                                                                                                                 pd.DataFrame(positiveFtrsDelta_death, index=[0]),
                                                                                                                                                ShapModelDeath)
    # Select and Display comments
    if sum(usedFeaturesImportance_death)/(sum(usedFeaturesImportance_death)+sum(missingFeaturesImportance_death)) < 0.60:
        contribNotes_death = html.P("")
    else:
        contribNotes_death = html.P("")
        
    # Compute the waterfall plot
    figWF_death = waterFallGraph(ftrsDelta_death)
    
    # Compute the PDTA Graph
    PDTA_Features = {'Age': age,
                      'eGFR (MDRD)': eGFR,
                      'ethnicity': ethnicity,
                      'Female': sex,
                      "PriorPCI": PriorPCI,
                      "Stent_DES": Stent_DES,
                      "AAS": AAS,
                      "clopidogrel": clopidogrel,
                      "Prasu": Prasu,  
                      "Tica": Tica,  
                      "hypertension": HyperT, 
                      "PriorStroke": PrStroke,
                      #"creatinine": 2.2,
                      "PriorBleeding": PrBleed}
    
    figPathPDTA = graphPathPDTA(PDTA_Features)
    
    #Compute Isotonic Bleeding Risk
    pdtaIsotinicRisk = iso_reg_barc.predict(np.expand_dims(pred_proba_test_patient_barc, axis=0))
    pdtaIsotinicRisk = round(pdtaIsotinicRisk[0]*100,4)
    figPathPDTAModel = graphPathPDTAModel(PDTA_Features,pdtaIsotinicRisk)
    
    return ({'display' : 'none'}, 
            figPieCalibratedPred_barc, figPiePred_barc, figPred_barc, figContrib_barc, figWF_barc, contribNotes_barc,
            figPieCalibratedPred_death, figPiePred_death, figPred_death, figContrib_death, figWF_death, contribNotes_death,
            figPathPDTA, figPathPDTAModel)


#+------------------------------------------------------------------------------------------------------+
#|     Update and display the contrinuous variables regression graphs (Age, LVEF, Creatinine, Hb)       |
#+------------------------------------------------------------------------------------------------------+

# AGE Graph
@app.callback(Output('graphAge_barc', 'figure'),
              Output('graphAge_death', 'figure'),
              Input('AgeSlider', 'value'))

def updateAge(value):
    fig_barc = shapScatterCurveFit(shap_complete_df_barc,"Age", "Age_SHAP", "Age_SHAP", ["Age", "Average Age Impact", "% Delta Risk"], "Risk Trend in Age",  
                              fitType = ShapModelBarc.fittedFeatures["Age"].type, myLevel = value)
    
    fig_death = shapScatterCurveFit(shap_complete_df_death,"Age", "Age_SHAP", "Age_SHAP", ["Age", "Average Age Impact", "% Delta Risk"], "Risk Trend in Age",  
                              fitType = ShapModelDeath.fittedFeatures["Age"].type, myLevel = value)
    return fig_barc, fig_death

# LVEF Graph
@app.callback(Output('graphLVEF_barc', 'figure'),
              Output('graphLVEF_death', 'figure'),
              Input('LVEFSlider', 'value'))

def updateLVEF(value):
    fig_barc = shapScatterCurveFit(shap_complete_df_barc,"LVEF", "LVEF_SHAP", "LVEF_SHAP", ["LVEF", "Average LVEF Impact", "% Delta Risk"], "Risk Trend in LVEF", 
                              fitType = ShapModelBarc.fittedFeatures["LVEF"].type, myLevel = value)
    
    fig_death = shapScatterCurveFit(shap_complete_df_death,"LVEF", "LVEF_SHAP", "LVEF_SHAP", ["LVEF", "Average LVEF Impact", "% Delta Risk"], "Risk Trend in LVEF", 
                              fitType = ShapModelDeath.fittedFeatures["LVEF"].type, myLevel = value)
    return fig_barc, fig_death

# LVEF Graph
@app.callback(Output('graphEGFR_barc', 'figure'),
              Output('graphEGFR_death', 'figure'),
              Input('EGFRSlider', 'value'))

def updateEGFR(value):
    fig_barc = shapScatterCurveFit(shap_complete_df_barc, "eGFR (MDRD)", "eGFR (MDRD)_SHAP", "eGFR (MDRD)_SHAP", ["eGFR (MDRD)", "Average eGFR Impact", "% Delta Risk"], "Risk Trend in eGFR", 
                              fitType = ShapModelBarc.fittedFeatures["eGFR (MDRD)"].type, myLevel = value)
    
    fig_death = shapScatterCurveFit(shap_complete_df_death, "eGFR (MDRD)", "eGFR (MDRD)_SHAP", "eGFR (MDRD)_SHAP", ["eGFR (MDRD)", "Average eGFR Impact", "% Delta Risk"], "Risk Trend in eGFR", 
                              fitType = ShapModelDeath.fittedFeatures["eGFR (MDRD)"].type, myLevel = value)
    return fig_barc, fig_death

#+------------------------------------------------------------------------------------------------------+
#|                                             Run the main app                                         |
#+------------------------------------------------------------------------------------------------------+
if __name__ =='__main__':
  ## Run the App in debug Mode with callbacks
  #app.run_server(mode="external")
  ## Run in execution mode without callbacks  
  app.run_server(mode="external")#, dev_tools_ui=False,dev_tools_props_check=False)




